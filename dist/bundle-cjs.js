/*
Lime version 0.2.2
Mathematics computation engine
2021 Lime Project Team, MIT license
https://github.com/onenylxus/lime
*/

"use strict";var github="Please create a GitHub issue about how you received this message, thank you. ",require$$0$1={github:github,"error:emptyArgumentInFinalize":"Empty argument in finalize function.","error:functionAgreement":"Function does not agree with parameter types.","error:invalidArgumentLength":"Invalid argument length.","error:invalidArgumentLogic":"Invalid argument logic.","error:invalidMatrixDimensions":"Invalid matrix dimensions.","error:invalidParametersInCommand":"Invalid parameters in command.","error:inputEmptyInDirect":"Direct input is empty.","error:inputEmptyInPrompt":"Prompt input is empty.","error:inputNotArrayInDirect":"Direct input is not an array.","error:inputNotStringInPrompt":"Prompt input is not a string.","error:invalidConfigProperty":"Invalid configuration property in config command","error:invalidListProperty":"Invalid list property in list command","error:invalidSymbol":"Invalid symbol in prompt input.","error:undefinedVariable":"Variable is undefined but used.","error:unmatchedBrackets":"Some brackets are unmatched.","issue:invalidExpressionInConstruct":"Invalid expression in constructor.","issue:invalidFunctionOrder":"Invalid function order.","issue:invalidMessage":"Invalid message detected.","issue:invalidModuleInBuild":"Invalid module in build function.","issue:invalidModuleInIdentify":"Invalid module in identify function.","issue:invalidResultLengthInProcess":"Invalid result length in process function.","issue:invalidTokenInParse":"Invalid token in parse function.","warn:negativeFactorial":"Factorial function has negative integer input. Currenly gamma function has not been implemented.","warn:strictBoolean":"Strict boolean configuration is set to true. Boolean to expression conversion is not allowed.","warn:zeroExponentOfZero":"Zero raised to exponent of zero is undefined."},about$1=["about"],clear$1=["clear"],config$1=["config"],help$1=["help"],list$1=["list"],i=["complex",["integer",0],["integer",1]],abs=["absolute","r"],ceil=["ceiling","r"],conj=["conjugate","r"],fibonacci$1=["fibonacci","r"],floor$1=["floor","r"],gcd=["greatestCommonDivisor","r"],idmat=["identityMatrix","r"],im=["imaginary","r"],lcm=["leastCommonMultiple","r"],max=["maximum","r"],mean$1=["mean","r"],min=["minimum","r"],ncr=["combination","r"],npr=["permutation","r"],onemat=["oneMatrix","r"],prime$1=["prime","r"],prod=["product","r"],rand=["random","r"],range$1=["range","r"],re=["real","r"],reciprocal$1=["reciprocal","r"],round$1=["round","r"],sgn=["sign","r"],sum$1=["sum","r"],trunc=["truncation","r"],zeromat=["zeroMatrix","r"],require$$1$1={about:about$1,clear:clear$1,config:config$1,help:help$1,list:list$1,false:["boolean",!1],i:i,true:["boolean",!0],"()":["argument",null],abs:abs,ceil:ceil,conj:conj,fibonacci:fibonacci$1,floor:floor$1,gcd:gcd,idmat:idmat,im:im,lcm:lcm,max:max,mean:mean$1,min:min,ncr:ncr,npr:npr,onemat:onemat,prime:prime$1,prod:prod,rand:rand,range:range$1,re:re,reciprocal:reciprocal$1,round:round$1,sgn:sgn,sum:sum$1,trunc:trunc,zeromat:zeromat,"+":["add","b"],"=":["assign","b"],"&":["bitwiseAnd","b"],"~":["bitwiseNot","r"],"|":["bitwiseOr","b"],",":["columnSplit","x"],"(":["commonBracket","n"],")":["commonBracket","x"],".":["decimal","b"],"/":["divide","b"],"==":["equal","b"],"^":["exponent","b"],"!":["factorial","l"],">":["greater","b"],">=":["greaterEqual","b"],"&&":["logicalAnd","b"],"_!":["logicalNot","r"],"||":["logicalOr","b"],"[":["matrixBracket","n"],"]":["matrixBracket","x"],"%":["modulo","b"],"*":["multiply","b"],"_-":["negative","r"],"!=":["notEqual","b"],"_+":["positive","r"],";":["rowSplit","x"],"<<":["shiftLeft","b"],">>":["shiftRight","b"],"<":["smaller","b"],"<=":["smallerEqual","b"],"-":["subtract","b"]};class Types$9{static isUndefined(...e){return e.every(e=>void 0===e)}static isNull(...e){return e.every(e=>null===e)}static isTrue(...e){return e.every(e=>!0===e)}static isFalse(...e){return e.every(e=>!1===e)}static isBoolean(...e){return e.every(e=>"boolean"==typeof e)}static isNumber(...e){return e.every(e=>"number"==typeof e)}static isString(...e){return e.every(e=>"string"==typeof e)}static isFunction(...e){return e.every(e=>"function"==typeof e)}static isArray(...e){return e.every(e=>e instanceof Array)}static isObject(...e){return e.every(e=>e instanceof Object)}static isClass(t,...e){return e.every(e=>e instanceof t)}}var types=Types$9,developmentMode=!1,promptShowRuntime=!1,promptShowSteps=!1,strictBoolean=!0,tabSize=2,testMode=!1,require$$3={developmentMode:developmentMode,promptShowRuntime:promptShowRuntime,promptShowSteps:promptShowSteps,strictBoolean:strictBoolean,tabSize:tabSize,testMode:testMode},name="@onenylxus/lime",version="0.2.2",description="Mathematics computation engine",author="Lime Project Team",license="MIT",keywords=["javascript","mathematics"],main="dist/bundle.js",module$2="dist/bundle-cjs.js",browser="dist/bundle-esm.js",sideEffects=!1,dependencies={},devDependencies={"@rollup/plugin-commonjs":"^20.0.0","@rollup/plugin-json":"^4.1.0","@rollup/plugin-node-resolve":"^13.0.0",codecov:"^3.8.2",eslint:"^7.25.0","eslint-config-airbnb-base":"^14.2.1","eslint-plugin-import":"^2.24.2",husky:"^7.0.2",jest:"^27.1.0","lint-staged":"^11.1.2","prettier-eslint":"^13.0.0","prettier-eslint-cli":"^5.0.1",rimraf:"^3.0.2",rollup:"^2.56.3","rollup-plugin-node-polyfills":"^0.2.1","rollup-plugin-uglify":"^6.0.4"},scripts={lint:"prettier-eslint '**/*.js'",clean:"rimraf dist/*.js",debug:"node examples/prompt.js -q",prebuild:"yarn lint && yarn clean",build:"rollup -c",watch:"jest --config jest.config.json --watch",pretest:"yarn build",test:"jest --config jest.config.json --verbose"},husky={hooks:{"pre-commit":"yarn test"}},repository={type:"git",url:"git+https://github.com/onenylxus/lime.git"},bugs={url:"https://github.com/onenylxus/lime/issues"},homepage="https://github.com/onenylxus/lime#readme",require$$0={name:name,version:version,description:description,author:author,license:license,keywords:keywords,main:main,module:module$2,browser:browser,sideEffects:sideEffects,dependencies:dependencies,devDependencies:devDependencies,scripts:scripts,husky:husky,repository:repository,bugs:bugs,homepage:homepage};const Package=require$$0;function banner$1(){return`Lime version ${Package.version}\n${Package.description}\n2021 ${Package.author}, ${Package.license} license\n${Package.homepage.slice(0,-7)}`}var banner_1=banner$1;class LimeCommand$5{constructor(e,{...t}){this.lime=e,this.name=t.hasOwnProperty("name")?t.name:this.constructor.name.slice(11),this.description=t.hasOwnProperty("description")?t.description:"",this.operations=new Map}execute(e){var t=e.split(/\s/).slice(1),e=t.length;if(!this.operations.has(e))throw new Error("error:invalidParametersInCommand");return this.operations.get(e)(...t)}}var command=LimeCommand$5;const banner=banner$1,LimeCommand$4=command;class LimeCommandAbout extends LimeCommand$4{constructor(e){super(e,{name:"about",description:"show information about the engine"}),this.operations.set(0,()=>banner())}}var about=LimeCommandAbout;const LimeCommand$3=command;class LimeCommandClear extends LimeCommand$3{constructor(e){super(e,{name:"clear",description:"clear variables and memory"}),this.operations.set(0,()=>(this.lime.variables=new Map,this.lime.memory=[],this.lime.store={},"Cleared"))}}var clear=LimeCommandClear;const LimeCommand$2=command;class LimeCommandConfig extends LimeCommand$2{constructor(e){super(e,{name:"config",description:"view and modify engine configurations"}),this.operations.set(1,e=>{if(!this.lime.config.hasOwnProperty(e))throw new Error("error:invalidConfigProperty");return`${e}: ${this.lime.config[e]}`}),this.operations.set(2,(e,t)=>{if(!this.lime.config.hasOwnProperty(e))throw new Error("error:invalidConfigProperty");var i=this.lime.config[e];return this.lime.config[e]=this.lime.direct([t]).value,`${e}: ${i} > ${this.lime.config[e]}`})}}var config=LimeCommandConfig;const LimeCommand$1=command;class LimeCommandHelp extends LimeCommand$1{constructor(e){super(e,{name:"help",description:"list all available commands"}),this.operations.set(0,()=>{const i=["Below is a list of available commands:"];return this.lime.module.forEach(e=>{try{var t=new e(this.lime);t instanceof LimeCommand$1&&i.push(`${t.name}: ${t.description}`)}catch(e){}}),i.join("\n")})}}var help=LimeCommandHelp;const LimeCommand=command,Types$8=types;class LimeCommandList extends LimeCommand{constructor(e){super(e,{name:"list",description:"list specified engine property"}),this.operations.set(1,e=>{if(!this.lime.hasOwnProperty(e)||Types$8.isFunction(this.lime[e]))throw new Error("error:invalidListProperty");return Types$8.isClass(Map,this.lime[e])?Object.fromEntries(this.lime[e]):this.lime[e]})}}var list=LimeCommandList;const Types$7=types;class LimeExpression$7{constructor(e,{...t}){this.lime=e,this.name=t.hasOwnProperty("name")?t.name:this.constructor.name.slice(12),this.isSimple=!t.hasOwnProperty("isSimple")||!Types$7.isBoolean(t.isSimple)||t.isSimple}}var expression=LimeExpression$7;const Types$6=types,LimeExpression$6=expression;class LimeExpressionArgument extends LimeExpression$6{constructor(e,...t){if(super(e,{name:"argument",isSimple:!1}),!this.lime.identify("expression")(...t)&&!Types$6.isNull(t[0]))throw new Error("issue:invalidExpressionInConstruct");this.places=t}get value(){return this.places.map(e=>e.value)}get length(){return this.isEmpty?0:this.places.length}get isEmpty(){return Types$6.isNull(this.places[0])}simplify(){return this.places.map(e=>e.simplify())}finalize(){if(this.isEmpty)throw new Error("error:emptyArgumentInFinalize");return 1===this.length?this.places[0].finalize():this.places.map(e=>e.finalize())}}var argument=LimeExpressionArgument;const LimeExpression$5=expression;class LimeExpressionBoolean extends LimeExpression$5{constructor(e,t){super(e,{name:"boolean",isSimple:!0}),this.raw=t}get value(){return!!this.raw}toInteger(){if(this.lime.config.strictBoolean)throw new Error("warn:strictBoolean");return this.lime.direct([+this.value])}simplify(){return this.lime.build("boolean")(this.value)}finalize(){return this.simplify()}print(){return this.value?"true":"false"}}var boolean=LimeExpressionBoolean;const LimeExpression$4=expression;class LimeExpressionComplex extends LimeExpression$4{constructor(e,t,i){if(super(e,{name:"complex",isSimple:!0}),!this.lime.identify("integer","rational")(t,i))throw new Error("issue:invalidExpressionInConstruct");this.rPlace=t,this.iPlace=i}get value(){return{r:this.rPlace.value,i:this.iPlace.value}}toBoolean(){return this.lime.build("boolean")(this.value.r||this.value.i)}simplify(){return this.lime.direct([this.iPlace,"==",0]).value?this.rPlace.simplify():this.lime.build("complex")(this.rPlace.simplify(),this.iPlace.simplify())}finalize(){return this.simplify()}print(){var e=this.lime.direct(["sgn","(",this.iPlace,")"]).value;return`${0===this.value.r?"":`${this.rPlace.print()}${0<e?"+":""}`}${1===this.value.i?"":-1===this.value.i?"-":this.iPlace.print()}i`}}var complex=LimeExpressionComplex;const LimeExpression$3=expression,Types$5=types;class LimeExpressionInteger extends LimeExpression$3{constructor(e,t){if(super(e,{name:"integer",isSimple:!0}),!Types$5.isNumber(+t))throw new Error("issue:invalidExpressionInConstruct");this.string=`${t}`}get value(){return Math.trunc(+this.string)}toBoolean(){return this.lime.build("boolean")(this.value)}toComplex(){return this.lime.build("complex")(this,this.lime.build("integer")(0))}toRational(){return this.lime.build("rational")(this,this.lime.build("integer")(1))}simplify(){return this.lime.build("integer")(this.value)}finalize(){return this.simplify()}print(){return`${this.value}`}}var integer=LimeExpressionInteger;const Types$4=types,LimeExpression$2=expression;class LimeExpressionMatrix extends LimeExpression$2{constructor(e,t){if(super(e,{name:"matrix",isSimple:!1}),!this.lime.identify("expression")(...t.flat())&&!Types$4.isNull(t[0][0]))throw new Error("issue:invalidExpressionInConstruct");const i=t[0].length;if(t.some(e=>e.length!==i))throw new Error("error:invalidMatrixDimensions");this.places=t}get value(){return this.places.map(e=>e.map(e=>e.value))}get row(){return this.isEmpty?0:this.places.length}get column(){return this.isEmpty?0:this.places[0].length}get isEmpty(){return Types$4.isNull(this.places[0][0])}simplify(){return this.places=this.places.map(e=>e.map(e=>e.simplify())),this}finalize(){return this.places=this.places.map(e=>e.map(e=>e.finalize())),this}print(){let i="";if(this.lime.config.testMode){i+="[";for(let t=0;t<this.row;t++){i+=0===t?"":";";for(let e=0;e<this.column;e++)i+=(0===e?"":",")+this.places[t][e].print()}i+="]"}else{var r=this.places.map(e=>e.map(e=>e.print().length));const n=[];for(let i=0;i<this.column;i++){let t=0;for(let e=0;e<this.row;e++)t=Math.max(r[e][i],t);n.push(t)}for(let t=0;t<this.row;t++){for(let e=0;e<this.column;e++)i+=new Array(n[e]-r[t][e]+this.lime.config.tabSize+1).join(" ")+this.places[t][e].print();i+=t<this.row-1?"\n":""}}return i}}var matrix=LimeExpressionMatrix;const LimeExpression$1=expression;class LimeExpressionRational extends LimeExpression$1{constructor(e,t,i){if(super(e,{name:"rational",isSimple:!0}),!this.lime.identify("integer")(t,i))throw new Error("issue:invalidExpressionInConstruct");this.nPlace=t,this.dPlace=i}get value(){return{n:this.nPlace.value,d:this.dPlace.value}}toBoolean(){return this.lime.build("boolean")(this.value.n/this.value.d)}toComplex(){return this.lime.build("complex")(this,this.lime.build("integer")(0))}simplify(){var e=this.lime.direct(["gcd","(",this.nPlace,",",this.dPlace,")"]);return this.nPlace=this.lime.direct([this.nPlace,"/",e]),this.dPlace=this.lime.direct([this.dPlace,"/",e]),this.value.d<0&&(this.nPlace=this.lime.direct(["-",this.nPlace]),this.dPlace=this.lime.direct(["-",this.dPlace])),1===this.value.d?this.nPlace.simplify():this.lime.build("rational")(this.nPlace.simplify(),this.dPlace.simplify())}finalize(){return this.simplify()}print(){return`${this.nPlace.print()}/${this.dPlace.print()}`}}var rational=LimeExpressionRational;const LimeExpression=expression;class LimeExpressionVariable extends LimeExpression{constructor(e,t){super(e,{name:"variable",isSimple:!0}),this.key=t}get value(){if(!this.lime.variables.has(this.key))throw new Error("error:undefinedVariable");return this.lime.variables.get(this.key)}simplify(){return this.value.simplify()}finalize(){return this.simplify()}}var variable=LimeExpressionVariable;const Oplist$1={cond:{"b(bool,bool)":e=>e.bpi("boolean"),"b(comp,comp)":e=>e.bpi("complex"),"b(comp,{int|rat})":e=>e.lpi("complex")&&e.rpi("integer","rational"),"b(expr,expr)":e=>e.bpi("expression"),"b(int,int)":e=>e.bpi("integer"),"b(int,rat)":e=>e.lpi("integer")&&e.rpi("rational"),"b(rat,int)":e=>e.lpi("rational")&&e.rpi("integer"),"b(rat,rat)":e=>e.bpi("rational"),"b(mat,mat)":e=>e.bpi("matrix"),"b(var,expr)":e=>e.lpi("variable")&&e.rpi("expression"),"b({int|rat},comp)":e=>e.lpi("integer","rational")&&e.rpi("complex"),"l(arg{expr[1]})":e=>e.lpi("argument")&&1===e.left.length&&e.ci("expression")(e.left.places[0]),"l(bool)":e=>e.lpi("boolean"),"l(int)":e=>e.lpi("integer"),"l(var)":e=>e.lpi("variable"),"l({comp|int|rat})":e=>e.lpi("complex","integer","rational"),"n()":()=>!0,"r(arg{})":e=>e.rpi("argument")&&e.right.isEmpty,"r(arg{comp[1]})":e=>e.rpi("argument")&&1===e.right.length&&e.ci("complex")(...e.right.places),"r(arg{expr[1]})":e=>e.rpi("argument")&&1===e.right.length&&e.ci("expression")(...e.right.places),"r(arg{expr[@]})":e=>e.rpi("argument")&&e.ci("expression")(...e.right.places),"r(arg{int[1]})":e=>e.rpi("argument")&&1===e.right.length&&e.ci("integer")(...e.right.places),"r(arg{int[2]})":e=>e.rpi("argument")&&2===e.right.length&&e.ci("integer")(...e.right.places),"r(arg{rat[1]})":e=>e.rpi("argument")&&1===e.right.length&&e.ci("rational")(...e.right.places),"r(arg{{int|rat}[$]})":t=>t.rpi("argument")&&t.right.places.some(e=>t.ci("integer","rational")(e)),"r(bool)":e=>e.rpi("boolean"),"r(int)":e=>e.rpi("integer"),"r(rat)":e=>e.rpi("rational"),"r(var)":e=>e.rpi("variable"),"r({comp|int|rat})":e=>e.rpi("complex","integer","rational"),"r(+)":e=>e.rpi("add"),"r(=)":e=>e.rpi("assign"),"r(&)":e=>e.rpi("bitwiseAnd"),"r(|)":e=>e.rpi("bitwiseOr"),"r(!)":e=>e.rpi("factorial"),"r(>)":e=>e.rpi("greater"),"r(_-)":e=>e.rpi("negative"),"r(_+)":e=>e.rpi("positive"),"r(<)":e=>e.rpi("smaller"),"r(-)":e=>e.rpi("subtract"),"z()":e=>0===e.pos},act:{"f(==)":e=>{e.rus(e.lime.refer("=="))},"f(!==)":e=>{e.rus(e.lime.refer("!"),e.lime.refer("=="))},"f(>=)":e=>{e.rus(e.lime.refer(">="))},"f(&&)":e=>{e.rus(e.lime.refer("&&"))},"f(_!)":e=>{e.fs(e.lime.refer("_!"))},"f(||)":e=>{e.rus(e.lime.refer("||"))},"f(_-)":e=>{e.fs(e.lime.refer("_-"))},"f(!=)":e=>{e.rus(e.lime.refer("!="))},"f(_+)":e=>{e.fs(e.lime.refer("_+"))},"f(<<)":e=>{e.rus(e.lime.refer("<<"))},"f(>>)":e=>{e.rus(e.lime.refer(">>"))},"f(<=)":e=>{e.rus(e.lime.refer("<="))},"l(arg{expr[1]}->expr)":e=>{e.lps(e.left.finalize())},"l(expr->int)":e=>{e.lps(e.left.toInteger())},"l(expr->rat)":e=>{e.lps(e.left.toRational())},"l(var->expr)":e=>{e.lps(e.left.value)},"l({comp|int|rat}->bool)":e=>{e.lps(e.left.toBoolean())},"l({int|rat}->comp)":e=>{e.lps(e.left.toComplex())},"r(arg{expr[1]}->expr)":e=>{e.rps(e.right.finalize())},"r(arg{{int|rat}[$]}->arg{comp[$]})":t=>{const e=t.right;e.places=e.places.map(e=>t.ci("integer","rational")(e)?e.toComplex():e),t.rps(e)},"r(expr->int)":e=>{e.rps(e.right.toInteger())},"r(expr->rat)":e=>{e.rps(e.right.toRational())},"r(var->expr)":e=>{e.rps(e.right.value)},"r({comp|int|rat}->bool)":e=>{e.rps(e.right.toBoolean())},"r({int|rat}->comp)":e=>{e.rps(e.right.toComplex())},"r(_!)":e=>{e.rps(e.lime.refer("_!"))},"r(_-)":e=>{e.rps(e.lime.refer("_-"))},"r(_+)":e=>{e.rps(e.lime.refer("_+"))}},pair:{"cb(comp,{int|rat}->comp)":["b(comp,{int|rat})","r({int|rat}->comp)"],"cb(int->rat,rat)":["b(int,rat)","l(expr->rat)"],"cb(rat,int->rat)":["b(rat,int)","r(expr->rat)"],"cb({int|rat}->comp,comp)":["b({int|rat},comp)","l({int|rat}->comp)"],"cl(arg{expr[1]}->expr)":["l(arg{expr[1]})","l(arg{expr[1]}->expr)"],"cl(bool->int)":["l(bool)","l(expr->int)"],"cl(var->expr)":["l(var)","l(var->expr)"],"cl({comp|int|rat}->bool)":["l({comp|int|rat})","l({comp|int|rat}->bool)"],"cr(arg{expr[1]}->expr)":["r(arg{expr[1]})","r(arg{expr[1]}->expr)"],"cr(arg{{int|rat}[$]}->arg{comp[$]})":["r(arg{{int|rat}[$]})","r(arg{{int|rat}[$]}->arg{comp[$]})"],"cr(bool->int)":["r(bool)","r(expr->int)"],"cr(var->expr)":["r(var)","r(var->expr)"],"cr({comp|int|rat}->bool)":["r({comp|int|rat})","r({comp|int|rat}->bool)"],"tf(==)":["r(=)","f(==)"],"tf(!==)":["r(=)","f(!==)"],"tf(>=)":["r(=)","f(>=)"],"tf(&&)":["r(&)","f(&&)"],"tf(||)":["r(|)","f(||)"],"tf(!=)":["r(=)","f(!=)"],"tf(<<)":["r(<)","f(<<)"],"tf(>>)":["r(>)","f(>>)"],"tf(<=)":["r(=)","f(<=)"],"tr(_!)":["r(!)","r(_!)"],"tr(_+)":["r(+)","r(_+)"],"tr(_-)":["r(-)","r(_-)"],"tz(_!)":["z()","f(_!)"],"tz(_+)":["z()","f(_+)"],"tz(_-)":["z()","f(_-)"]}};var oplist=Oplist$1,require$$1=[["columnSplit","rowSplit"],["assign","equal","greater","greaterEqual","notEqual","smaller","smallerEqual"],["add","bitwiseAnd","bitwiseNot","bitwiseOr","logicalAnd","logicalNot","logicalOr","modulo","shiftLeft","shiftRight","subtract"],["divide","multiply"],["exponent"],["decimal","negative","positive"],["absolute","ceiling","combination","conjugate","factorial","fibonacci","floor","greatestCommonDivisor","identityMatrix","imaginary","leastCommonMultiple","maximum","mean","minimum","oneMatrix","permutation","prime","product","random","range","real","reciprocal","round","sign","sum","truncation","zeroMatrix"],["commonBracket","matrixBracket","omitted"]];const Oplist=Oplist$1,Order=require$$1,Types$3=types;class LimeFunction$U{constructor(e,{...t}){this.lime=e,this.mode=t.hasOwnProperty("mode")&&["l","r","b","n"].includes(t.mode)?t.mode:"x",this.name=t.hasOwnProperty("name")?t.name:this.constructor.name.slice(12),this.operations={},this.algorithms=new Map}get order(){for(let e=0;e<Order.length;e++)if(Order[e].includes(this.name))return e;throw new Error("issue:invalidFunctionOrder")}evaluate(r){if("x"===this.mode)throw new Error("error:unmatchedBrackets");const n=this.operations[this.mode];for(let i=0;i<n.length;i++){let e,t;if(Types$3.isString(n[i])&&(e="e"===n[i][0]?Oplist.cond[n[i].substring(1)]:Oplist.cond[Oplist.pair[n[i]][0]],t="e"===n[i][0]?this.algorithms.get(n[i].substring(1)):Oplist.act[Oplist.pair[n[i]][1]]),e(r))return t(r),r}throw new Error("error:functionAgreement")}}var _function=LimeFunction$U;const LimeFunction$T=_function;class LimeFunctionAdd extends LimeFunction$T{constructor(e,t){super(e,{name:"add",mode:t}),this.operations.b=["tz(_+)","tr(_!)","tr(_+)","tr(_-)","cl(var->expr)","cr(var->expr)","cl(arg{expr[1]}->expr)","cr(arg{expr[1]}->expr)","cl(bool->int)","cr(bool->int)","cb(int->rat,rat)","cb(rat,int->rat)","cb({int|rat}->comp,comp)","cb(comp,{int|rat}->comp)","eb(int,int)","eb(rat,rat)","eb(comp,comp)","eb(mat,mat)"],this.algorithms.set("b(int,int)",e=>{e.bs(this.lime.build("integer")(e.left.value+e.right.value))}),this.algorithms.set("b(rat,rat)",e=>{e.bs(this.lime.build("rational")(this.lime.direct([e.left.nPlace,"*",e.right.dPlace,"+",e.right.nPlace,"*",e.left.dPlace]),this.lime.direct([e.left.dPlace,"*",e.right.dPlace])))}),this.algorithms.set("b(comp,comp)",e=>{e.bs(this.lime.build("complex")(this.lime.direct([e.left.rPlace,"+",e.right.rPlace]),this.lime.direct([e.left.iPlace,"+",e.right.iPlace])))}),this.algorithms.set("b(mat,mat)",i=>{if(i.left.row!==i.right.row||i.left.column!==i.right.column)throw new Error("error:invalidMatrixDimensions");const r=[];for(let t=0;t<i.left.row;t++){r.push([]);for(let e=0;e<i.left.column;e++)r[t].push(this.lime.direct([i.left.places[t][e],"+",i.right.places[t][e]]))}i.bs(this.lime.build("matrix")(r))})}}var add=LimeFunctionAdd;const LimeFunction$S=_function;class LimeFunctionDecimal extends LimeFunction$S{constructor(e,t){super(e,{name:"decimal",mode:t}),this.operations.b=["eb(int,int)"],this.algorithms.set("b(int,int)",e=>{var t;0<e.right.value?(t=this.lime.direct([10,"^",e.right.string.length]),e.bs(this.lime.direct(["(",e.left,"*",t,"+",e.right,")","/",t]))):e.bs(e.left)})}}var decimal=LimeFunctionDecimal;const LimeFunction$R=_function;class LimeFunctionDivide extends LimeFunction$R{constructor(e,t){super(e,{name:"divide",mode:t}),this.operations.b=["tr(_!)","tr(_+)","tr(_-)","cl(var->expr)","cr(var->expr)","cl(arg{expr[1]}->expr)","cr(arg{expr[1]}->expr)","cl(bool->int)","cr(bool->int)","cb(int->rat,rat)","cb(rat,int->rat)","cb({int|rat}->comp,comp)","cb(comp,{int|rat}->comp)","eb(int,int)","eb(rat,rat)","eb(comp,comp)"],this.algorithms.set("b(int,int)",e=>{e.left.value%e.right.value==0?e.bs(this.lime.build("integer")(e.left.value/e.right.value)):e.bs(this.lime.build("rational")(e.left,e.right))}),this.algorithms.set("b(rat,rat)",e=>{e.bs(this.lime.build("rational")(this.lime.direct([e.left.nPlace,"*",e.right.dPlace]),this.lime.direct([e.left.dPlace,"*",e.right.nPlace])))}),this.algorithms.set("b(comp,comp)",e=>{e.bs(this.lime.build("complex")(this.lime.direct(["re","(",e.left,"*","conj","(",e.right,")",")","/","(",e.right,"*","conj","(",e.right,")",")"]),this.lime.direct(["im","(",e.left,"*","conj","(",e.right,")",")","/","(",e.right,"*","conj","(",e.right,")",")"])))})}}var divide=LimeFunctionDivide;const LimeFunction$Q=_function;class LimeFunctionExponent extends LimeFunction$Q{constructor(e,t){super(e,{name:"exponent",mode:t}),this.operations.b=["tr(_!)","tr(_+)","tr(_-)","cl(var->expr)","cr(var->expr)","cl(arg{expr[1]}->expr)","cr(arg{expr[1]}->expr)","cl(bool->int)","cr(bool->int)","eb(int,int)","eb(rat,int)"],this.algorithms.set("b(int,int)",e=>{if(0<=e.right.value){if(0===e.left.value&&0===e.right.value)throw new Error("warn:zeroExponentOfZero");e.bs(this.lime.build("integer")(e.left.value**e.right.value))}else e.bs(this.lime.build("rational")(this.lime.direct([1]),this.lime.direct([e.left,"^","-",e.right])))}),this.algorithms.set("b(rat,int)",e=>{0<=e.right.value?e.bs(this.lime.build("rational")(this.lime.direct([e.left.nPlace,"^",e.right]),this.lime.direct([e.left.dPlace,"^",e.right]))):e.bs(this.lime.build("rational")(this.lime.direct([e.left.dPlace,"^","-",e.right]),this.lime.direct([e.left.nPlace,"^","-",e.right])))})}}var exponent=LimeFunctionExponent;const LimeFunction$P=_function;class LimeFunctionModulo extends LimeFunction$P{constructor(e,t){super(e,{name:"modulo",mode:t}),this.operations.b=["tr(_!)","tr(_+)","tr(_-)","cl(var->expr)","cr(var->expr)","cl(arg{expr[1]}->expr)","cr(arg{expr[1]}->expr)","cl(bool->int)","cr(bool->int)","eb(int,int)"],this.algorithms.set("b(int,int)",e=>{e.bs(this.lime.build("integer")(e.left.value%e.right.value))})}}var modulo=LimeFunctionModulo;const LimeFunction$O=_function;class LimeFunctionMultiply extends LimeFunction$O{constructor(e,t){super(e,{name:"multiply",mode:t}),this.operations.b=["tr(_!)","tr(_+)","tr(_-)","cl(var->expr)","cr(var->expr)","cl(arg{expr[1]}->expr)","cr(arg{expr[1]}->expr)","cl(bool->int)","cr(bool->int)","cb(int->rat,rat)","cb(rat,int->rat)","cb({int|rat}->comp,comp)","cb(comp,{int|rat}->comp)","eb(int,int)","eb(rat,rat)","eb(comp,comp)","eb(mat,mat)"],this.algorithms.set("b(int,int)",e=>{e.bs(this.lime.build("integer")(e.left.value*e.right.value))}),this.algorithms.set("b(rat,rat)",e=>{e.bs(this.lime.build("rational")(this.lime.direct([e.left.nPlace,"*",e.right.nPlace]),this.lime.direct([e.left.dPlace,"*",e.right.dPlace])))}),this.algorithms.set("b(comp,comp)",e=>{e.bs(this.lime.build("complex")(this.lime.direct([e.left.rPlace,"*",e.right.rPlace,"-",e.left.iPlace,"*",e.right.iPlace]),this.lime.direct([e.left.rPlace,"*",e.right.iPlace,"+",e.left.iPlace,"*",e.right.rPlace])))}),this.algorithms.set("b(mat,mat)",n=>{if(n.left.column!==n.right.row)throw new Error("error:invalidMatrixDimensions");const e=[];for(let r=0;r<n.left.row;r++){e.push([]);for(let i=0;i<n.right.column;i++){let t=this.lime.direct([0]);for(let e=0;e<n.right.row;e++)t=this.lime.direct([t,"+",n.left.places[r][e],"*",n.right.places[e][i]]);e[r].push(t)}}n.bs(this.lime.build("matrix")(e))})}}var multiply=LimeFunctionMultiply;const LimeFunction$N=_function;class LimeFunctionNegative extends LimeFunction$N{constructor(e,t){super(e,{name:"negative",mode:t}),this.operations.r=["tr(_!)","tr(_+)","tr(_-)","cr(var->expr)","cr(arg{expr[1]}->expr)","cr(bool->int)","er(int)","er(rat)","er(_+)","er(_-)"],this.algorithms.set("r(int)",e=>{e.rus(this.lime.direct([-1,"*",e.right]))}),this.algorithms.set("r(rat)",e=>{e.rus(this.lime.build("rational")(this.lime.direct(["-",e.right.nPlace]),e.right.dPlace))}),this.algorithms.set("r(_+)",e=>{e.rus(this.lime.refer("_-"))}),this.algorithms.set("r(_-)",e=>{e.rus(this.lime.refer("_+"))})}}var negative=LimeFunctionNegative;const LimeFunction$M=_function;class LimeFunctionPositive extends LimeFunction$M{constructor(e,t){super(e,{name:"positive",mode:t}),this.operations.r=["tr(_!)","tr(_+)","tr(_-)","cr(var->expr)","cr(arg{expr[1]}->expr)","cr(bool->int)","er(int)","er(rat)","er(_+)","er(_-)"],this.algorithms.set("r(int)",e=>{e.rus(this.lime.direct([1,"*",e.right]))}),this.algorithms.set("r(rat)",e=>{e.rus(this.lime.build("rational")(this.lime.direct([e.right.nPlace]),e.right.dPlace))}),this.algorithms.set("r(_+)",e=>{e.rus(this.lime.refer("_+"))}),this.algorithms.set("r(_-)",e=>{e.rus(this.lime.refer("_-"))})}}var positive=LimeFunctionPositive;const LimeFunction$L=_function;class LimeFunctionSubtract extends LimeFunction$L{constructor(e,t){super(e,{name:"subtract",mode:t}),this.operations.b=["tz(_-)","tr(_!)","tr(_+)","tr(_-)","cl(var->expr)","cr(var->expr)","cl(arg{expr[1]}->expr)","cr(arg{expr[1]}->expr)","cl(bool->int)","cr(bool->int)","cb(int->rat,rat)","cb(rat,int->rat)","cb({int|rat}->comp,comp)","cb(comp,{int|rat}->comp)","eb(int,int)","eb(rat,rat)","eb(comp,comp)","eb(mat,mat)"],this.algorithms.set("b(int,int)",e=>{e.bs(this.lime.build("integer")(e.left.value-e.right.value))}),this.algorithms.set("b(rat,rat)",e=>{e.bs(this.lime.build("rational")(this.lime.direct([e.left.nPlace,"*",e.right.dPlace,"-",e.right.nPlace,"*",e.left.dPlace]),this.lime.direct([e.left.dPlace,"*",e.right.dPlace])))}),this.algorithms.set("b(comp,comp)",e=>{e.bs(this.lime.build("complex")(this.lime.direct([e.left.rPlace,"-",e.right.rPlace]),this.lime.direct([e.left.iPlace,"-",e.right.iPlace])))}),this.algorithms.set("b(mat,mat)",i=>{if(i.left.row!==i.right.row||i.left.column!==i.right.column)throw new Error("error:invalidMatrixDimensions");const r=[];for(let t=0;t<i.left.row;t++){r.push([]);for(let e=0;e<i.left.column;e++)r[t].push(this.lime.direct([i.left.places[t][e],"-",i.right.places[t][e]]))}i.bs(this.lime.build("matrix")(r))})}}var subtract=LimeFunctionSubtract;const LimeFunction$K=_function;class LimeFunctionBitwiseAnd extends LimeFunction$K{constructor(e,t){super(e,{name:"bitwiseAnd",mode:t}),this.operations.b=["tf(&&)","tr(_!)","tr(_+)","tr(_-)","cl(var->expr)","cr(var->expr)","cl(arg{expr[1]}->expr)","cr(arg{expr[1]}->expr)","cl(bool->int)","cr(bool->int)","eb(int,int)"],this.algorithms.set("b(int,int)",e=>{e.bs(this.lime.direct([e.left.value&e.right.value]))})}}var bitwiseAnd=LimeFunctionBitwiseAnd;const LimeFunction$J=_function;class LimeFunctionBitwiseNot extends LimeFunction$J{constructor(e,t){super(e,{name:"bitwiseNot",mode:t}),this.operations.r=["tr(_!)","tr(_+)","tr(_-)","cr(var->expr)","cr(arg{expr[1]}->expr)","cr(bool->int)","er(int)"],this.algorithms.set("r(int)",e=>{e.rus(this.lime.direct([~e.right.value]))})}}var bitwiseNot=LimeFunctionBitwiseNot;const LimeFunction$I=_function;class LimeFunctionBitwiseOr extends LimeFunction$I{constructor(e,t){super(e,{name:"bitwiseOr",mode:t}),this.operations.b=["tf(||)","tr(_!)","tr(_+)","tr(_-)","cl(var->expr)","cr(var->expr)","cl(arg{expr[1]}->expr)","cr(arg{expr[1]}->expr)","cl(bool->int)","cr(bool->int)","eb(int,int)"],this.algorithms.set("b(int,int)",e=>{e.bs(this.lime.direct([e.left.value|e.right.value]))})}}var bitwiseOr=LimeFunctionBitwiseOr;const LimeFunction$H=_function;class LimeFunctionShiftLeft extends LimeFunction$H{constructor(e,t){super(e,{name:"shiftLeft",mode:t}),this.operations.b=["tr(_!)","tr(_+)","tr(_-)","cl(var->expr)","cr(var->expr)","cl(arg{expr[1]}->expr)","cr(arg{expr[1]}->expr)","cl(bool->int)","cr(bool->int)","eb(int,int)"],this.algorithms.set("b(int,int)",e=>{e.bs(this.lime.direct([e.left.value<<e.right.value]))})}}var shiftLeft=LimeFunctionShiftLeft;const LimeFunction$G=_function;class LimeFunctionShiftRight extends LimeFunction$G{constructor(e,t){super(e,{name:"shiftRight",mode:t}),this.operations.b=["tr(_!)","tr(_+)","tr(_-)","cl(var->expr)","cr(var->expr)","cl(arg{expr[1]}->expr)","cr(arg{expr[1]}->expr)","cl(bool->int)","cr(bool->int)","eb(int,int)"],this.algorithms.set("b(int,int)",e=>{e.bs(this.lime.direct([e.left.value>>e.right.value]))})}}var shiftRight=LimeFunctionShiftRight;const LimeFunction$F=_function;class LimeFunctionEqual extends LimeFunction$F{constructor(e,t){super(e,{name:"equal",mode:t}),this.operations.b=["tr(_!)","tr(_+)","tr(_-)","cl(var->expr)","cr(var->expr)","cl(arg{expr[1]}->expr)","cr(arg{expr[1]}->expr)","cl(bool->int)","cr(bool->int)","cb(int->rat,rat)","cb(rat,int->rat)","eb(int,int)","eb(rat,rat)"],this.algorithms.set("b(int,int)",e=>{e.bs(this.lime.build("boolean")(e.left.value===e.right.value))}),this.algorithms.set("b(rat,rat)",e=>{e.bs(this.lime.direct([e.left.nPlace,"*",e.right.dPlace,"==",e.right.nPlace,"*",e.left.dPlace]))})}}var equal=LimeFunctionEqual;const LimeFunction$E=_function;class LimeFunctionGreater extends LimeFunction$E{constructor(e,t){super(e,{name:"greater",mode:t}),this.operations.b=["tf(>=)","tf(>>)","tr(_!)","tr(_+)","tr(_-)","cl(var->expr)","cr(var->expr)","cl(arg{expr[1]}->expr)","cr(arg{expr[1]}->expr)","cl(bool->int)","cr(bool->int)","cb(int->rat,rat)","cb(rat,int->rat)","eb(int,int)","eb(rat,rat)"],this.algorithms.set("b(int,int)",e=>{e.bs(this.lime.build("boolean")(e.left.value>e.right.value))}),this.algorithms.set("b(rat,rat)",e=>{e.bs(this.lime.direct([e.left.nPlace,"*",e.right.dPlace,">",e.right.nPlace,"*",e.left.dPlace]))})}}var greater=LimeFunctionGreater;const LimeFunction$D=_function;class LimeFunctionGreaterEqual extends LimeFunction$D{constructor(e,t){super(e,{name:"greaterEqual",mode:t}),this.operations.b=["tr(_!)","tr(_+)","tr(_-)","cl(var->expr)","cr(var->expr)","cl(arg{expr[1]}->expr)","cr(arg{expr[1]}->expr)","cl(bool->int)","cr(bool->int)","cb(int->rat,rat)","cb(rat,int->rat)","eb(int,int)","eb(rat,rat)"],this.algorithms.set("b(int,int)",e=>{e.bs(this.lime.build("boolean")(e.left.value>=e.right.value))}),this.algorithms.set("b(rat,rat)",e=>{e.bs(this.lime.direct([e.left.nPlace,"*",e.right.dPlace,">=",e.right.nPlace,"*",e.left.dPlace]))})}}var greaterEqual=LimeFunctionGreaterEqual;const LimeFunction$C=_function;class LimeFunctionNotEqual extends LimeFunction$C{constructor(e,t){super(e,{name:"notEqual",mode:t}),this.operations.b=["tf(!==)","tr(_!)","tr(_+)","tr(_-)","cl(var->expr)","cr(var->expr)","cl(arg{expr[1]}->expr)","cr(arg{expr[1]}->expr)","cl(bool->int)","cr(bool->int)","cb(int->rat,rat)","cb(rat,int->rat)","eb(int,int)","eb(rat,rat)"],this.algorithms.set("b(int,int)",e=>{e.bs(this.lime.build("boolean")(e.left.value!==e.right.value))}),this.algorithms.set("b(rat,rat)",e=>{e.bs(this.lime.direct([e.left.nPlace,"*",e.right.dPlace,"!=",e.right.nPlace,"*",e.left.dPlace]))})}}var notEqual=LimeFunctionNotEqual;const LimeFunction$B=_function;class LimeFunctionSmaller extends LimeFunction$B{constructor(e,t){super(e,{name:"smaller",mode:t}),this.operations.b=["tf(<=)","tf(<<)","tr(_!)","tr(_+)","tr(_-)","cl(var->expr)","cr(var->expr)","cl(arg{expr[1]}->expr)","cr(arg{expr[1]}->expr)","cl(bool->int)","cr(bool->int)","cb(int->rat,rat)","cb(rat,int->rat)","eb(int,int)","eb(rat,rat)"],this.algorithms.set("b(int,int)",e=>{e.bs(this.lime.build("boolean")(e.left.value<e.right.value))}),this.algorithms.set("b(rat,rat)",e=>{e.bs(this.lime.direct([e.left.nPlace,"*",e.right.dPlace,"<",e.right.nPlace,"*",e.left.dPlace]))})}}var smaller=LimeFunctionSmaller;const LimeFunction$A=_function;class LimeFunctionSmallerEqual extends LimeFunction$A{constructor(e,t){super(e,{name:"smallerEqual",mode:t}),this.operations.b=["tr(_!)","tr(_+)","tr(_-)","cl(var->expr)","cr(var->expr)","cl(arg{expr[1]}->expr)","cr(arg{expr[1]}->expr)","cl(bool->int)","cr(bool->int)","cb(int->rat,rat)","cb(rat,int->rat)","eb(int,int)","eb(rat,rat)"],this.algorithms.set("b(int,int)",e=>{e.bs(this.lime.build("boolean")(e.left.value<=e.right.value))}),this.algorithms.set("b(rat,rat)",e=>{e.bs(this.lime.direct([e.left.nPlace,"*",e.right.dPlace,"<=",e.right.nPlace,"*",e.left.dPlace]))})}}var smallerEqual=LimeFunctionSmallerEqual;const LimeFunction$z=_function;class LimeFunctionConjugate extends LimeFunction$z{constructor(e,t){super(e,{name:"conjugate",mode:t}),this.operations.r=["cr(arg{{int|rat}[$]}->arg{comp[$]})","er(arg{comp[1]})"],this.algorithms.set("r(arg{comp[1]})",e=>{e.rus(this.lime.build("complex")(e.right.places[0].rPlace,this.lime.direct(["-",e.right.places[0].iPlace])))})}}var conjugate=LimeFunctionConjugate;const LimeFunction$y=_function;class LimeFunctionImaginary extends LimeFunction$y{constructor(e,t){super(e,{name:"imaginary",mode:t}),this.operations.r=["cr(arg{{int|rat}[$]}->arg{comp[$]})","er(arg{comp[1]})"],this.algorithms.set("r(arg{comp[1]})",e=>{e.rus(this.lime.direct([e.right.places[0].iPlace]))})}}var imaginary=LimeFunctionImaginary;const LimeFunction$x=_function;class LimeFunctionReal extends LimeFunction$x{constructor(e,t){super(e,{name:"real",mode:t}),this.operations.r=["cr(arg{{int|rat}[$]}->arg{comp[$]})","er(arg{comp[1]})"],this.algorithms.set("r(arg{comp[1]})",e=>{e.rus(this.lime.direct([e.right.places[0].rPlace]))})}}var real=LimeFunctionReal;const LimeFunction$w=_function;class LimeFunctionCombination extends LimeFunction$w{constructor(e,t){super(e,{name:"combination",mode:t}),this.operations.r=["er(arg{int[2]})"],this.algorithms.set("r(arg{int[2]})",e=>{var[t,i]=e.right.places;if(t.value<i.value)throw new Error("error:invalidArgumentLogic");e.rus(this.lime.direct(["npr","(",t,",",i,")","/",i,"!"]))})}}var combination=LimeFunctionCombination;const LimeFunction$v=_function;class LimeFunctionFactorial extends LimeFunction$v{constructor(e,t){super(e,{name:"factorial",mode:t}),this.operations.l=["tz(_!)","tf(!=)","cl(var->expr)","cl(arg{expr[1]}->expr)","cl(bool->int)","el(int)"],this.algorithms.set("l(int)",e=>{if(e.left.value<0)throw new Error("warn:negativeFactorial");0<e.left.value?e.lus(this.lime.direct([e.left,"*","(",e.left,"-",1,")","!"])):e.lus(this.lime.direct([1]))})}}var factorial=LimeFunctionFactorial;const LimeFunction$u=_function;class LimeFunctionPermutation extends LimeFunction$u{constructor(e,t){super(e,{name:"permutation",mode:t}),this.operations.r=["er(arg{int[2]})"],this.algorithms.set("r(arg{int[2]})",e=>{var[t,i]=e.right.places;if(t.value<i.value)throw new Error("error:invalidArgumentLogic");e.rus(this.lime.direct([t,"!","/","(",t,"-",i,")","!"]))})}}var permutation=LimeFunctionPermutation;const LimeFunction$t=_function;class LimeFunctionLogicalAnd extends LimeFunction$t{constructor(e,t){super(e,{name:"logicalAnd",mode:t}),this.operations.b=["tr(_!)","tr(_+)","tr(_-)","cl(var->expr)","cr(var->expr)","cl(arg{expr[1]}->expr)","cr(arg{expr[1]}->expr)","cl({comp|int|rat}->bool)","cr({comp|int|rat}->bool)","eb(bool,bool)"],this.algorithms.set("b(bool,bool)",e=>{e.bs(this.lime.build("boolean")(e.left.value&&e.right.value))})}}var logicalAnd=LimeFunctionLogicalAnd;const LimeFunction$s=_function;class LimeFunctionLogicalNot extends LimeFunction$s{constructor(e,t){super(e,{name:"logicalNot",mode:t}),this.operations.r=["tr(_!)","tr(_+)","tr(_-)","cr(var->expr)","cr(arg{expr[1]}->expr)","cr({comp|int|rat}->bool)","er(bool)"],this.algorithms.set("r(bool)",e=>{e.rus(this.lime.build("boolean")(!e.right.value))})}}var logicalNot=LimeFunctionLogicalNot;const LimeFunction$r=_function;class LimeFunctionLogicalOr extends LimeFunction$r{constructor(e,t){super(e,{name:"logicalOr",mode:t}),this.operations.b=["tr(_!)","tr(_+)","tr(_-)","cl(var->expr)","cr(var->expr)","cl(arg{expr[1]}->expr)","cr(arg{expr[1]}->expr)","cl({comp|int|rat}->bool)","cr({comp|int|rat}->bool)","eb(bool,bool)"],this.algorithms.set("b(bool,bool)",e=>{e.bs(this.lime.build("boolean")(e.left.value||e.right.value))})}}var logicalOr=LimeFunctionLogicalOr;const LimeFunction$q=_function;class LimeFunctionIdentityMatrix extends LimeFunction$q{constructor(e,t){super(e,{name:"identityMatrix",mode:t}),this.operations.r=["er(arg{int[1]})"],this.algorithms.set("r(arg{int[1]})",i=>{const r=[];for(let t=0;t<i.right.value[0];t++){r.push([]);for(let e=0;e<i.right.value[0];e++)r[t].push(this.lime.direct([e===t?1:0]))}i.rus(this.lime.build("matrix")(r))})}}var identityMatrix=LimeFunctionIdentityMatrix;const LimeFunction$p=_function;class LimeFunctionOneMatrix extends LimeFunction$p{constructor(e,t){super(e,{name:"oneMatrix",mode:t}),this.operations.r=["er(arg{int[1]})","er(arg{int[2]})"],this.algorithms.set("r(arg{int[1]})",i=>{const r=[];for(let t=0;t<i.right.value[0];t++){r.push([]);for(let e=0;e<i.right.value[0];e++)r[t].push(this.lime.direct([1]))}i.rus(this.lime.build("matrix")(r))}),this.algorithms.set("r(arg{int[2]})",i=>{const r=[];for(let t=0;t<i.right.value[0];t++){r.push([]);for(let e=0;e<i.right.value[1];e++)r[t].push(this.lime.direct([1]))}i.rus(this.lime.build("matrix")(r))})}}var oneMatrix=LimeFunctionOneMatrix;const LimeFunction$o=_function;class LimeFunctionZeroMatrix extends LimeFunction$o{constructor(e,t){super(e,{name:"zeroMatrix",mode:t}),this.operations.r=["er(arg{int[1]})","er(arg{int[2]})"],this.algorithms.set("r(arg{int[1]})",i=>{const r=[];for(let t=0;t<i.right.value[0];t++){r.push([]);for(let e=0;e<i.right.value[0];e++)r[t].push(this.lime.direct([0]))}i.rus(this.lime.build("matrix")(r))}),this.algorithms.set("r(arg{int[2]})",i=>{const r=[];for(let t=0;t<i.right.value[0];t++){r.push([]);for(let e=0;e<i.right.value[1];e++)r[t].push(this.lime.direct([0]))}i.rus(this.lime.build("matrix")(r))})}}var zeroMatrix=LimeFunctionZeroMatrix;const LimeFunction$n=_function;class LimeFunctionAbsolute extends LimeFunction$n{constructor(e,t){super(e,{name:"absolute",mode:t}),this.operations.r=["er(arg{int[1]})","er(arg{rat[1]})"],this.algorithms.set("r(arg{int[1]})",e=>{e.rus(this.lime.direct([Math.abs(e.right.value[0])]))}),this.algorithms.set("r(arg{rat[1]})",e=>{e.rus(this.lime.direct([Math.abs(e.right.value[0].n),"/",Math.abs(e.right.value[0].d)]))})}}var absolute=LimeFunctionAbsolute;const LimeFunction$m=_function;class LimeFunctionCeiling extends LimeFunction$m{constructor(e,t){super(e,{name:"ceiling",mode:t}),this.operations.r=["er(arg{int[1]})","er(arg{rat[1]})"],this.algorithms.set("r(arg{int[1]})",e=>{e.rus(this.lime.direct([e.right.value[0]]))}),this.algorithms.set("r(arg{rat[1]})",e=>{e.rus(this.lime.direct([Math.ceil(e.right.value[0].n/e.right.value[0].d)]))})}}var ceiling=LimeFunctionCeiling;const LimeFunction$l=_function;class LimeFunctionFibonacci extends LimeFunction$l{constructor(e,t){super(e,{name:"fibonacci",mode:t}),this.operations.r=["er(arg{int[1]})"],this.algorithms.set("r(arg{int[1]})",e=>{var t=e.right.value[0];if(t<1)throw new Error("error:invalidArgumentLogic");this.lime.store.hasOwnProperty("fibonacci")||(this.lime.store.fibonacci=[1,1]);const i=[...this.lime.store.fibonacci];for(;i.length<t;)i.push(i[i.length-2]+i[i.length-1]);this.lime.store.fibonacci=[...i],e.rus(this.lime.direct([i[t-1]]))})}}var fibonacci=LimeFunctionFibonacci;const LimeFunction$k=_function;class LimeFunctionFloor extends LimeFunction$k{constructor(e,t){super(e,{name:"floor",mode:t}),this.operations.r=["er(arg{int[1]})","er(arg{rat[1]})"],this.algorithms.set("r(arg{int[1]})",e=>{e.rus(this.lime.direct([e.right.value[0]]))}),this.algorithms.set("r(arg{rat[1]})",e=>{e.rus(this.lime.direct([Math.floor(e.right.value[0].n/e.right.value[0].d)]))})}}var floor=LimeFunctionFloor;const LimeFunction$j=_function;class LimeFunctionGreatestCommonDivisor extends LimeFunction$j{constructor(e,t){super(e,{name:"greatestCommonDivisor",mode:t}),this.operations.r=["er(arg{int[2]})"],this.algorithms.set("r(arg{int[2]})",e=>{let t=e.right.value[0],i=e.right.value[1];for(;0!==i;){var r=i;i=t%i,t=r}e.rus(this.lime.direct([t]))})}}var greatestCommonDivisor=LimeFunctionGreatestCommonDivisor;const LimeFunction$i=_function;class LimeFunctionLeastCommonMultiple extends LimeFunction$i{constructor(e,t){super(e,{name:"leastCommonMultiple",mode:t}),this.operations.r=["er(arg{int[2]})"],this.algorithms.set("r(arg{int[2]})",e=>{var t=e.right.value[0],i=e.right.value[1];e.rus(this.lime.direct([t,"*",i,"/","gcd","(",t,",",i,")"]))})}}var leastCommonMultiple=LimeFunctionLeastCommonMultiple;const LimeFunction$h=_function;class LimeFunctionPrime extends LimeFunction$h{constructor(e,t){super(e,{name:"prime",mode:t}),this.operations.r=["er(arg{int[1]})"],this.algorithms.set("r(arg{int[1]})",e=>{var t=e.right.value[0];if(t<1)throw new Error("error:invalidArgumentLogic");this.lime.store.hasOwnProperty("prime")||(this.lime.store.prime=[2]);const i=[...this.lime.store.prime];let r=i[i.length-1]+1;for(;i.length<t;)i.every(e=>r%e!=0)&&i.push(r),r++;this.lime.store.prime=[...i],e.rus(this.lime.direct([i[t-1]]))})}}var prime=LimeFunctionPrime;const LimeFunction$g=_function;class LimeFunctionReciprocal extends LimeFunction$g{constructor(e,t){super(e,{name:"reciprocal",mode:t}),this.operations.r=["er(arg{expr[1]})"],this.algorithms.set("r(arg{expr[1]})",e=>{e.rus(this.lime.direct([1,"/",e.right.places[0]]))})}}var reciprocal=LimeFunctionReciprocal;const LimeFunction$f=_function;class LimeFunctionRound extends LimeFunction$f{constructor(e,t){super(e,{name:"round",mode:t}),this.operations.r=["er(arg{int[1]})","er(arg{rat[1]})"],this.algorithms.set("r(arg{int[1]})",e=>{e.rus(this.lime.direct([e.right.value[0]]))}),this.algorithms.set("r(arg{rat[1]})",e=>{e.rus(this.lime.direct([Math.round(e.right.value[0].n/e.right.value[0].d)]))})}}var round=LimeFunctionRound;const LimeFunction$e=_function;class LimeFunctionSign extends LimeFunction$e{constructor(e,t){super(e,{name:"sign",mode:t}),this.operations.r=["er(arg{int[1]})","er(arg{rat[1]})"],this.algorithms.set("r(arg{int[1]})",e=>{e.rus(this.lime.direct([Math.sign(e.right.value[0])]))}),this.algorithms.set("r(arg{rat[1]})",e=>{e.rus(this.lime.direct([Math.sign(e.right.value[0].n/e.right.value[0].d)]))})}}var sign=LimeFunctionSign;const LimeFunction$d=_function;class LimeFunctionTruncation extends LimeFunction$d{constructor(e,t){super(e,{name:"truncation",mode:t}),this.operations.r=["er(arg{int[1]})","er(arg{rat[1]})"],this.algorithms.set("r(arg{int[1]})",e=>{e.rus(this.lime.direct([e.right.value[0]]))}),this.algorithms.set("r(arg{rat[1]})",e=>{e.rus(this.lime.direct([Math.trunc(e.right.value[0].n/e.right.value[0].d)]))})}}var truncation=LimeFunctionTruncation;const LimeFunction$c=_function;class LimeFunctionMaximum extends LimeFunction$c{constructor(e,t){super(e,{name:"maximum",mode:t}),this.operations.r=["er(arg{expr[@]})"],this.algorithms.set("r(arg{expr[@]})",t=>{if(0===t.right.length)throw new Error("error:invalidArgumentLength");let i=0;for(let e=1;e<t.right.length;e++)i=this.lime.direct([t.right.places[e],">",t.right.places[i]]).value?e:i;t.rus(this.lime.direct([t.right.places[i]]))})}}var maximum=LimeFunctionMaximum;const LimeFunction$b=_function;class LimeFunctionMean extends LimeFunction$b{constructor(e,t){super(e,{name:"mean",mode:t}),this.operations.r=["er(arg{expr[@]})"],this.algorithms.set("r(arg{expr[@]})",e=>{if(0===e.right.length)throw new Error("error:invalidArgumentLength");e.rus(this.lime.direct(["sum",e.right,"/",e.right.length]))})}}var mean=LimeFunctionMean;const LimeFunction$a=_function;class LimeFunctionMinimum extends LimeFunction$a{constructor(e,t){super(e,{name:"minimum",mode:t}),this.operations.r=["er(arg{expr[@]})"],this.algorithms.set("r(arg{expr[@]})",t=>{if(0===t.right.length)throw new Error("error:invalidArgumentLength");let i=0;for(let e=1;e<t.right.length;e++)i=this.lime.direct([t.right.places[e],"<",t.right.places[i]]).value?e:i;t.rus(this.lime.direct([t.right.places[i]]))})}}var minimum=LimeFunctionMinimum;const LimeFunction$9=_function;class LimeFunctionProduct extends LimeFunction$9{constructor(e,t){super(e,{name:"product",mode:t}),this.operations.r=["er(arg{expr[@]})"],this.algorithms.set("r(arg{expr[@]})",t=>{if(0===t.right.length)throw new Error("error:invalidArgumentLength");let i=t.right.places[0];for(let e=1;e<t.right.length;e++)i=this.lime.direct([i,"*",t.right.places[e]]);t.rus(this.lime.direct([i]))})}}var product=LimeFunctionProduct;const LimeFunction$8=_function;class LimeFunctionRandom extends LimeFunction$8{constructor(e,t){super(e,{name:"random",mode:t}),this.operations.r=["er(arg{})","er(arg{int[1]})","er(arg{int[2]})"],this.algorithms.set("r(arg{})",e=>{e.rus(this.lime.direct([Math.floor(1e15*Math.random()),"/",1e15]))}),this.algorithms.set("r(arg{int[1]})",e=>{e.rus(this.lime.direct(["rand","(",0,",",e.right.places[0],")"]))}),this.algorithms.set("r(arg{int[2]})",e=>{var[t,i]=e.right.places;if(this.lime.direct([t.value,">",i.value]).value)throw new Error("error:invalidArgumentLogic");e.rus(this.lime.direct([Math.floor(Math.random()*(i.value-t.value+1)+t.value)]))})}}var random=LimeFunctionRandom;const LimeFunction$7=_function;class LimeFunctionRange extends LimeFunction$7{constructor(e,t){super(e,{name:"range",mode:t}),this.operations.r=["er(arg{expr[@]})"],this.algorithms.set("r(arg{expr[@]})",e=>{if(0===e.right.length)throw new Error("error:invalidArgumentLength");e.rus(this.lime.direct(["max",e.right,"-","min",e.right]))})}}var range=LimeFunctionRange;const LimeFunction$6=_function;class LimeFunctionSum extends LimeFunction$6{constructor(e,t){super(e,{name:"sum",mode:t}),this.operations.r=["er(arg{expr[@]})"],this.algorithms.set("r(arg{expr[@]})",t=>{if(0===t.right.length)throw new Error("error:invalidArgumentLength");let i=t.right.places[0];for(let e=1;e<t.right.length;e++)i=this.lime.direct([i,"+",t.right.places[e]]);t.rus(this.lime.direct([i]))})}}var sum=LimeFunctionSum;const LimeFunction$5=_function;class LimeFunctionAssign extends LimeFunction$5{constructor(e,t){super(e,{name:"assign",mode:t}),this.operations.b=["tf(==)","tr(_+)","tr(_-)","cr(var->expr)","cr(arg{expr[1]}->expr)","eb(var,expr)"],this.algorithms.set("b(var,expr)",e=>{this.lime.variables.set(e.left.key,e.right),e.bs(e.left)})}}var assign=LimeFunctionAssign;const LimeFunction$4=_function;class LimeFunctionColumnSplit extends LimeFunction$4{constructor(e,t){super(e,{name:"columnSplit",mode:t})}}var columnSplit=LimeFunctionColumnSplit;const LimeFunction$3=_function;class LimeFunctionCommonBracket extends LimeFunction$3{constructor(e,t){super(e,{name:"commonBracket",mode:t}),this.operations.n=["en()"],this.algorithms.set("n()",e=>{var t=e["data"];const i=[[]],r=[this];let n=e.pos,s=0;for(;n+1<t.length&&0<r.length;){if(this.lime.identify("commonBracket","matrixBracket")(t[n+1]))if("n"===t[n+1].mode)r.push(t[n+1]);else{if(t[n+1].name!==r[r.length-1].name)throw new Error("error:unmatchedBrackets");if(r.pop(),0===r.length)break}else if(this.lime.identify("columnSplit")(t[n+1]))i.push([]),s++,n++;else if(this.lime.identify("rowSplit")(t[n+1])&&1===r.length)throw new Error("error:functionAgreement");i[s].push(t[++n])}if(0<r.length)throw new Error("error:unmatchedBrackets");const o=[];let a=2+s;for(let e=0;e<=s;e++)a+=i[e].length,o.push(0<i[e].length?this.lime.direct(i[e]):null);e.ns(a,this.lime.build("argument")(...o))})}}var commonBracket=LimeFunctionCommonBracket;const LimeFunction$2=_function;class LimeFunctionMatrixBracket extends LimeFunction$2{constructor(e,t){super(e,{name:"matrixBracket",mode:t}),this.operations.n=["en()"],this.algorithms.set("n()",e=>{var t=e["data"];const i=[[[]]],r=[this];let n=e.pos,s=0,o=0;for(;n+1<t.length&&0<r.length;){if(this.lime.identify("commonBracket","matrixBracket")(t[n+1]))if("n"===t[n+1].mode)r.push(t[n+1]);else{if(t[n+1].name!==r[r.length-1].name)throw new Error("error:unmatchedBrackets");if(r.pop(),0===r.length)break}else if(this.lime.identify("columnSplit")(t[n+1]))i[s].push([]),o++,n++;else if(this.lime.identify("rowSplit")(t[n+1])){if(0<s&&i[s].length!==i[0].length)throw new Error;i.push([[]]),s++,o=0,n++}i[s][o].push(t[++n])}if(0<r.length)throw new Error("error:unmatchedBrackets");const a=[];let l=++s*++o+1;for(let t=0;t<s;t++){a.push([]);for(let e=0;e<o;e++)l+=i[t][e].length,a[t].push(0<i[t][e].length?this.lime.direct(i[t][e]):null)}e.ns(l,this.lime.build("matrix")(a))})}}var matrixBracket=LimeFunctionMatrixBracket;const LimeFunction$1=_function;class LimeFunctionOmitted extends LimeFunction$1{constructor(e,t){super(e,{name:"omitted",mode:t}),this.operations.b=["eb(expr,expr)"],this.algorithms.set("b(expr,expr)",e=>{e.fs(e.lime.refer("*"))})}}var omitted=LimeFunctionOmitted;const LimeFunction=_function;class LimeFunctionRowSplit extends LimeFunction{constructor(e,t){super(e,{name:"rowSplit",mode:t})}}var rowSplit=LimeFunctionRowSplit;class LimeEquation{constructor(e,t){this.lime=e,this.input=t,this.solution=[]}get steps(){return this.solution.length}get runtime(){return this.solution[this.steps-1].timestamp-this.solution[0].timestamp}get result(){return this.solution[this.steps-1].data}record(e){this.lime.config.promptShowSteps&&console.log(e.data),this.solution.push(e)}}var equation=LimeEquation;const Types$2=types;class LimeStep{constructor(e,t,i){this.lime=e,this.data=Types$2.isArray(t)?t:[],this.pos=Types$2.isNumber(i)&&0<=i&&i<this.data.length?i:-1,this.timestamp=Date.now()}get left(){return this.data[this.pos-1]}get func(){return this.data[this.pos]}get right(){return this.data[this.pos+1]}ci(...t){return(...e)=>this.lime.identify(...t)(...e)}lpi(...e){return this.lime.identify(...e)(this.left)}fi(...e){return this.lime.identify(...e)(this.func)}rpi(...e){return this.lime.identify(...e)(this.right)}bpi(...e){return this.lime.identify(...e)(this.left,this.right)}lps(...e){this.data.splice(this.pos-1,1,...e)}fs(...e){this.data.splice(this.pos,1,...e)}rps(...e){this.data.splice(this.pos+1,1,...e)}lus(...e){this.data.splice(this.pos-1,2,...e)}rus(...e){this.data.splice(this.pos,2,...e)}bs(...e){this.data.splice(this.pos-1,3,...e)}ns(e,...t){this.data.splice(this.pos,e,...t)}}var step=LimeStep;const Types$1=types;class LimeToken{constructor(e,t,i){this.lime=e,this.type=["integer","whitespace","symbol","variable"].includes(t)?t:"symbol",this.value=Types$1.isString(i)?i:""}}var token=LimeToken;const Module$1=new Map;Module$1.set("about",about),Module$1.set("clear",clear),Module$1.set("config",config),Module$1.set("help",help),Module$1.set("list",list),Module$1.set("argument",argument),Module$1.set("boolean",boolean),Module$1.set("complex",complex),Module$1.set("integer",integer),Module$1.set("matrix",matrix),Module$1.set("rational",rational),Module$1.set("variable",variable),Module$1.set("add",add),Module$1.set("decimal",decimal),Module$1.set("divide",divide),Module$1.set("exponent",exponent),Module$1.set("modulo",modulo),Module$1.set("multiply",multiply),Module$1.set("negative",negative),Module$1.set("positive",positive),Module$1.set("subtract",subtract),Module$1.set("bitwiseAnd",bitwiseAnd),Module$1.set("bitwiseNot",bitwiseNot),Module$1.set("bitwiseOr",bitwiseOr),Module$1.set("shiftLeft",shiftLeft),Module$1.set("shiftRight",shiftRight),Module$1.set("equal",equal),Module$1.set("greater",greater),Module$1.set("greaterEqual",greaterEqual),Module$1.set("notEqual",notEqual),Module$1.set("smaller",smaller),Module$1.set("smallerEqual",smallerEqual),Module$1.set("conjugate",conjugate),Module$1.set("imaginary",imaginary),Module$1.set("real",real),Module$1.set("combination",combination),Module$1.set("factorial",factorial),Module$1.set("permutation",permutation),Module$1.set("logicalAnd",logicalAnd),Module$1.set("logicalNot",logicalNot),Module$1.set("logicalOr",logicalOr),Module$1.set("identityMatrix",identityMatrix),Module$1.set("oneMatrix",oneMatrix),Module$1.set("zeroMatrix",zeroMatrix),Module$1.set("absolute",absolute),Module$1.set("ceiling",ceiling),Module$1.set("fibonacci",fibonacci),Module$1.set("floor",floor),Module$1.set("greatestCommonDivisor",greatestCommonDivisor),Module$1.set("leastCommonMultiple",leastCommonMultiple),Module$1.set("prime",prime),Module$1.set("reciprocal",reciprocal),Module$1.set("round",round),Module$1.set("sign",sign),Module$1.set("truncation",truncation),Module$1.set("maximum",maximum),Module$1.set("mean",mean),Module$1.set("minimum",minimum),Module$1.set("product",product),Module$1.set("random",random),Module$1.set("range",range),Module$1.set("sum",sum),Module$1.set("assign",assign),Module$1.set("columnSplit",columnSplit),Module$1.set("commonBracket",commonBracket),Module$1.set("matrixBracket",matrixBracket),Module$1.set("omitted",omitted),Module$1.set("rowSplit",rowSplit),Module$1.set("command",command),Module$1.set("equation",equation),Module$1.set("expression",expression),Module$1.set("function",_function),Module$1.set("step",step),Module$1.set("token",token);var module$1=Module$1;const Message=require$$0$1,Refer=require$$1$1,Types=types,Config=require$$3,Module=module$1;class Lime{constructor(e){this.config={...Config,...e},this.module=Module,this.variables=new Map,this.memory=[],this.store={}}get answer(){return this.variables.get("ans").print()}prompt(e){try{return this.run(e)}catch(e){return this.message(e)}}evaluate(e){try{return this.run(e)}catch(e){return console.log(this.message(e)),""}}run(e){if(!Types.isString(e))throw new Error("error:inputNotStringInPrompt");if(0===e.length)throw new Error("error:inputEmptyInPrompt");this.variables.has("ans")||this.variables.set("ans",this.direct([0]));const t=this.build("equation")(e);return this.lex(t),this.identify("command")(t.result[0])?t.result[0].execute(e):(this.memory.push(t),this.config.promptShowRuntime&&console.log(`Equation runtime: ${t.runtime/1e3}s`),this.variables.set("ans",t.result[0]),this.answer)}direct(e){try{if(!Types.isArray(e))throw new Error("error:inputNotArrayInDirect");if(0===e.length)throw new Error("error:inputEmptyInDirect");const t=this.build("equation")(e);return t.record(this.build("step")(t.input.map(e=>!Types.isString(e)&&!Types.isNumber(e)||Types.isUndefined(this.refer(e))?e:this.refer(e)))),this.process(t),t.result[0]}catch(e){return this.config.testMode?this.message(e):void console.log(this.message(e))}}message(e){var t=new Error("issue:invalidMessage");if(!Message.hasOwnProperty(e.message)||!e.message.includes(":"))return console.log(e),this.message(t);var i=e.message.split(":");let r;switch(i[0]){case"error":r="!";break;case"warn":r="?";break;case"issue":r="i";break;default:return this.message(t)}return this.config.developmentMode&&"i"===r&&console.log(e),`[${r}] ${i[1]}\n${Message[e.message]} ${"i"===r?`\n${Message.github}`:""}`}lex(e){const i=e.input,r=[];for(let t=0;t<i.length;t++){const n=i[t];let e=n;if(n.match(/\s/))r.push(this.build("token")("whitespace"));else if(n.match(/\d/)){for(;t+1<i.length&&i[t+1].match(/\d/);)e+=i[++t];r.push(this.build("token")("integer",e))}else if(n.match(/\w/)){for(;t+1<i.length&&i[t+1].match(/\w/);)e+=i[++t];r.push(this.build("token")("variable",e))}else r.push(this.build("token")("symbol",e))}e.record(r),this.parse(e)}parse(e){var t=e.solution.shift();const i=[];for(let e=0;e<t.length;e++)switch(t[e].type){case"whitespace":break;case"integer":i.push(this.build("integer")(t[e].value));break;case"symbol":case"variable":if(Refer.hasOwnProperty(t[e].value))i.push(this.refer(t[e].value));else{if("variable"!==t[e].type)throw new Error("error:invalidSymbol");i.push(this.build("variable")(t[e].value))}break;default:throw new Error("issue:invalidTokenInParse")}e.record(this.build("step")(i)),this.identify("command")(e.result[0])||this.process(e)}process(i){for(;;){for(let e=0;e<i.result.length;e++)0<e&&this.identify("expression")(i.result[e-1],i.result[e])&&i.result.splice(e,0,this.build("omitted")("b"));let t=-1;for(let e=0;e<i.result.length;e++)this.identify("function")(i.result[e])&&(t=t<0||i.result[e].order>i.result[t].order?e:t);if(t<0)break;var e=this.build("step")(i.result,t);i.record(i.result[t].evaluate(e))}if(1!==i.result.length||this.identify("argument")(i.result[0])&&1!==i.result[0].length)throw new Error("issue:invalidResultLengthInProcess");i.record(this.build("step")([i.result[0].finalize()]))}identify(...i){if(i.every(e=>this.module.has(e)))return(...e)=>e.every(t=>i.some(e=>Types.isClass(this.module.get(e),t)));throw new Error("issue:invalidModuleInIdentify")}build(t){if(this.module.has(t))return(...e)=>new(this.module.get(t))(this,...e);throw new Error("issue:invalidModuleInBuild")}refer(e){return Types.isNumber(e)?this.build("integer")(e):Refer.hasOwnProperty(e)?this.build(Refer[e][0])(...Refer[e].slice(1).map(e=>Types.isArray(e)?this.build(e[0])(...e.slice(1)):e)):void 0}}var lime=e=>new Lime(e);module.exports=lime;
