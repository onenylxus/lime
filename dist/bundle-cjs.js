/*
Lime version 0.1.0
Mathematics computation engine
2021 Lime Project Team, MIT license
https://github.com/onenylxus/lime
*/

"use strict";var github="Please create a GitHub issue about how you received this message, thank you. ",Message={github:github,"error:functionAgreement":"Function does not agree with parameter types.","error:inputEmptyInDirect":"Direct input is empty.","error:inputEmptyInPrompt":"Prompt input is empty.","error:inputNotArrayInDirect":"Direct input is not an array.","error:inputNotStringInPrompt":"Prompt input is not a string.","error:invalidSymbol":"Invalid symbol in prompt input.","error:unmatchedBrackets":"Some brackets are unmatched.","issue:invalidExpressionInConstruct":"Invalid expression in constructor.","issue:invalidFunctionOrder":"Invalid function order.","issue:invalidMessage":"Invalid message detected.","issue:invalidModuleInBuild":"Invalid module in build process.","issue:invalidTokenInParse":"Invalid token in parse process."},Refer={"+":["add","b"],"(":["commonBracket","n"],")":["commonBracket","x"],"/":["divide","b"],"*":["multiply","b"],"-":["subtract","b"]};class Types$1{static isUndefined(...e){return e.every(e=>void 0===e)}static isNull(...e){return e.every(e=>null===e)}static isTrue(...e){return e.every(e=>!0===e)}static isFalse(...e){return e.every(e=>!1===e)}static isBoolean(...e){return e.every(e=>"boolean"==typeof e)}static isNumber(...e){return e.every(e=>"number"==typeof e)}static isString(...e){return e.every(e=>"string"==typeof e)}static isFunction(...e){return e.every(e=>"function"==typeof e)}static isArray(...e){return e.every(e=>e instanceof Array)}static isObject(...e){return e.every(e=>e instanceof Object)}static isClass(t,...e){return e.every(e=>e instanceof t)}}var types=Types$1,developmentMode=!1,testMode=!1,require$$0$1={developmentMode:developmentMode,testMode:testMode},Types=types;class LimeExpression{constructor(e,{...t}){this.lime=e,this.isSimple=!t.hasOwnProperty("isSimple")||!Types.isBoolean(t.isSimple)||t.isSimple}}var expression=LimeExpression,require$$8=LimeExpression;class LimeInteger extends require$$8{constructor(e,t){if(super(e,{isSimple:!0}),!Types.isNumber(+t))throw new Error("issue:invalidExpressionInConstruct");this.value=Math.trunc(+t)}toRational(){return this.lime.build("rational")(this,this.lime.build("integer")(1))}print(){return`${this.value}`}}var integer=LimeInteger;class LimeRational extends require$$8{constructor(e,t,i){if(super(e,{isSimple:!0}),!this.lime.identify("integer")(t,i))throw new Error("issue:invalidExpressionInConstruct");this.nPlace=t,this.dPlace=i,this.value.d<0&&(this.value.n*=-1,this.value.d*=-1)}get value(){return{n:this.nPlace.value,d:this.dPlace.value}}print(){return`${this.value.n}/${this.value.d}`}}var rational=LimeRational;const Oplist$1={cond:{"b(int,int)":e=>e.bpi("integer"),"b(int,rat)":e=>e.lpi("integer")&&e.rpi("rational"),"b(rat,int)":e=>e.lpi("rational")&&e.rpi("integer"),"b(rat,rat)":e=>e.bpi("rational"),"n()":()=>!0},act:{"l(int>rat)":e=>{e.lps(e.left.toRational())},"r(int>rat)":e=>{e.rps(e.right.toRational())}},pair:{"cb(int>rat,rat)":["b(int,rat)","l(int>rat)"],"cb(rat,int>rat)":["b(rat,int)","r(int>rat)"]}};var oplist=Oplist$1,Order=[["add","subtract"],["divide","multiply"],["commonBracket"]],Oplist=oplist;class LimeFunction{constructor(e,{...t}){this.lime=e,this.mode=t.hasOwnProperty("mode")&&["l","r","b","n"].includes(t.mode)?t.mode:"x",this.name=t.hasOwnProperty("name")?t.name:this.constructor.name.slice(4),this.operations={l:[],r:[],b:[],n:[]},this.algorithms=new Map}get order(){for(let e=0;e<Order.length;e++)if(Order[e].includes(this.name))return e;throw new Error("issue:invalidFunctionOrder")}evaluate(r){if("x"===this.mode)throw new Error("error:unmatchedBrackets");const s=this.operations[this.mode];for(let i=0;i<s.length;i++){let e,t;if(Types.isString(s[i])&&(e="e"===s[i][0]?Oplist.cond[s[i].substring(1)]:Oplist.cond[Oplist.pair[s[i]][0]],t="e"===s[i][0]?this.algorithms.get(s[i].substring(1)):Oplist.act[Oplist.pair[s[i]][1]]),e(r))return t(r),r}throw new Error("error:functionAgreement")}}var _function=LimeFunction,require$$9=LimeFunction;class LimeFunctionAdd extends require$$9{constructor(e,t){super(e,{name:"add",mode:t}),this.operations.b=["cb(int>rat,rat)","cb(rat,int>rat)","eb(int,int)","eb(rat,rat)"],this.algorithms.set("b(int,int)",e=>{e.bs(this.lime.build("integer")(e.left.value+e.right.value))}),this.algorithms.set("b(rat,rat)",e=>{e.bs(this.lime.build("rational")(this.lime.build("integer")(e.left.value.n*e.right.value.d+e.right.value.n*e.left.value.d),this.lime.build("integer")(e.left.value.d*e.right.value.d)))})}}var add=LimeFunctionAdd;class LimeFunctionDivide extends require$$9{constructor(e,t){super(e,{name:"divide",mode:t}),this.operations.b=["cb(int>rat,rat)","cb(rat,int>rat)","eb(int,int)","eb(rat,rat)"],this.algorithms.set("b(int,int)",e=>{e.left.value%e.right.value==0?e.bs(this.lime.build("integer")(e.left.value/e.right.value)):e.bs(this.lime.build("rational")(e.left,e.right))}),this.algorithms.set("b(rat,rat)",e=>{e.bs(this.lime.build("rational")(this.lime.build("integer")(e.left.value.n*e.right.value.d),this.lime.build("integer")(e.left.value.d*e.right.value.n)))})}}var divide=LimeFunctionDivide;class LimeFunctionMultiply extends require$$9{constructor(e,t){super(e,{name:"multiply",mode:t}),this.operations.b=["cb(int>rat,rat)","cb(rat,int>rat)","eb(int,int)","eb(rat,rat)"],this.algorithms.set("b(int,int)",e=>{e.bs(this.lime.build("integer")(e.left.value*e.right.value))}),this.algorithms.set("b(rat,rat)",e=>{e.bs(this.lime.build("rational")(this.lime.build("integer")(e.left.value.n*e.right.value.n),this.lime.build("integer")(e.left.value.d*e.right.value.d)))})}}var multiply=LimeFunctionMultiply;class LimeFunctionSubtract extends require$$9{constructor(e,t){super(e,{name:"subtract",mode:t}),this.operations.b=["cb(int>rat,rat)","cb(rat,int>rat)","eb(int,int)","eb(rat,rat)"],this.algorithms.set("b(int,int)",e=>{e.bs(this.lime.build("integer")(e.left.value-e.right.value))}),this.algorithms.set("b(rat,rat)",e=>{e.bs(this.lime.build("rational")(this.lime.build("integer")(e.left.value.n*e.right.value.d-e.right.value.n*e.left.value.d),this.lime.build("integer")(e.left.value.d*e.right.value.d)))})}}var subtract=LimeFunctionSubtract;class LimeFunctionCommonBracket extends require$$9{constructor(e,t){super(e,{name:"commonBracket",mode:t}),this.operations.n=["en()"],this.algorithms.set("n()",e=>{const t=e["data"],i=[];let r=e.pos,s=0;for(;r+1<t.length&&!(this.lime.identify("commonBracket")(t[r+1])&&(s+="n"===t[r+1].mode?1:-1,s<0));)i.push(t[++r]);if(0<=s)throw new Error("error:unmatchedBrackets");e.ns(i.length+2,this.lime.direct([...i]))})}}var commonBracket=LimeFunctionCommonBracket;class LimeEquation{constructor(e,t){this.lime=e,this.input=t,this.solution=[]}get steps(){return this.solution.length}get result(){return this.solution[this.steps-1].data}record(e){this.solution.push(e)}}var equation=LimeEquation;class LimeStep{constructor(e,t,i){this.lime=e,this.data=Types.isArray(t)?t:[],this.pos=Types.isNumber(i)&&0<=i&&i<this.data.length?i:-1,this.timestamp=Date.now()}get left(){return this.data[this.pos-1]}get func(){return this.data[this.pos]}get right(){return this.data[this.pos+1]}lpi(...e){return this.lime.identify(...e)(this.left)}fi(...e){return this.lime.identify(...e)(this.func)}rpi(...e){return this.lime.identify(...e)(this.right)}bpi(...e){return this.lime.identify(...e)(this.left,this.right)}lps(e){this.data.splice(this.pos-1,1,e)}fs(e){this.data.splice(this.pos,1,e)}rps(e){this.data.splice(this.pos+1,1,e)}lus(e){this.data.splice(this.pos-1,2,e)}rus(e){this.data.splice(this.pos,2,e)}bs(e){this.data.splice(this.pos-1,3,e)}ns(e,t){this.data.splice(this.pos,e,t)}}var step=LimeStep;class LimeToken{constructor(e,t,i){this.lime=e,this.type=["integer","whitespace","symbol","variable"].includes(t)?t:"symbol",this.value=Types.isString(i)?i:""}}var token=LimeToken,require$$0=integer,require$$1$1=rational,require$$2=add,require$$3=divide,require$$4=multiply,require$$5=subtract,require$$6=commonBracket,require$$7=equation,require$$10=step,require$$11=LimeToken;const Module=new Map;Module.set("integer",require$$0),Module.set("rational",require$$1$1),Module.set("add",require$$2),Module.set("divide",require$$3),Module.set("multiply",require$$4),Module.set("subtract",require$$5),Module.set("commonBracket",require$$6),Module.set("equation",require$$7),Module.set("expression",require$$8),Module.set("function",require$$9),Module.set("step",require$$10),Module.set("token",require$$11);var module$1=Module,require$$1=Module;class Lime{constructor(e){this.config={...require$$0$1,...e},this.module=require$$1,this.flags={},this.constants={},this.variables={ans:void 0},this.memory=[]}get answer(){return this.variables.ans.print()}prompt(e){try{if(!Types.isString(e))throw new Error("error:inputNotStringInPrompt");if(0===e.length)throw new Error("error:inputEmptyInPrompt");var t=this.build("equation")(e);return this.lex(t),this.memory.push(t),[this.variables.ans]=t.result,this.answer}catch(e){return this.message(e)}}direct(e){try{if(!Types.isArray(e))throw new Error("error:inputNotArrayInDirect");if(0===e.length)throw new Error("error:inputEmptyInDirect");const t=this.build("equation")(e);return t.record(this.build("step")(t.input.map(e=>!Types.isString(e)&&!Types.isNumber(e)||Types.isUndefined(this.refer(e))?e:this.refer(e)))),this.process(t),t.result[0]}catch(e){return this.message(e)}}message(e){var t=new Error("issue:invalidMessage");if(!Message.hasOwnProperty(e.message)||!e.message.includes(":"))return console.log(e),this.message(t);var i=e.message.split(":");let r;switch(i[0]){case"error":r="!";break;case"warn":r="?";break;case"issue":r="i";break;default:return this.message(t)}return this.config.developmentMode&&"i"===r&&console.log(e),`[${r}] ${i[1]}\n${Message[e.message]} ${"i"===r?`\n${Message.github}`:""}`}lex(e){const i=e.input,r=[];for(let t=0;t<i.length;t++){const s=i[t];let e=s;if(s.match(/\s/))r.push(this.build("token")("whitespace"));else if(s.match(/\d/)){for(;t+1<i.length&&i[t+1].match(/\d/);)e+=i[++t];r.push(this.build("token")("integer",e))}else if(s.match(/\w/)){for(;t+1<i.length&&i[t+1].match(/\w/);)e+=i[++t];r.push(this.build("token")("variable",e))}else r.push(this.build("token")("symbol",e))}e.record(r),this.parse(e)}parse(e){const t=e.solution.shift(),i=[];for(let e=0;e<t.length;e++)switch(t[e].type){case"whitespace":break;case"integer":i.push(this.build("integer")(t[e].value));break;case"symbol":case"variable":if(Refer.hasOwnProperty(t[e].value))i.push(this.refer(t[e].value));else{if("variable"!==t[e].type)throw new Error("error:invalidSymbol");i.push(this.build("variable")(t[e].value))}break;default:throw new Error("issue:invalidTokenInParse")}e.record(this.build("step")(i)),this.process(e)}process(i){for(;;){let t=-1;for(let e=0;e<i.result.length;e++)this.identify("function")(i.result[e])&&(t=t<0||i.result[e].order>i.result[t].order?e:t);if(t<0)break;var e=this.build("step")(i.result,t);i.record(i.result[t].evaluate(e))}}identify(...i){return(...e)=>e.every(t=>i.some(e=>Types.isClass(this.module.get(e),t)))}build(t){if(this.module.has(t))return(...e)=>new(this.module.get(t))(this,...e);throw new Error("issue:invalidModuleInBuild")}refer(e){return Types.isNumber(e)?this.build("integer")(e):Refer.hasOwnProperty(e)?this.build(Refer[e][0])(...Refer[e].slice(1).map(e=>Types.isArray(e)?this.build(e[0])(...e.slice(1)):e)):void 0}}var lime=e=>new Lime(e);module.exports=lime;
