/*
Lime version 0.3.0
Mathematics computation engine
2021 Lime Project Team, MIT license
https://github.com/onenylxus/lime
*/

class Integer{constructor(t,e,i=0){this._signed=t,this._size=e,this.set(i)}get(){return this._value}set(t){this._value=this.clamp(this.constructor.toNumber(t))}inc(t){return this.set(this.get()+1),this.clamp(t?this.get()-1:this.get())}dec(t){return this.set(this.get()-1),this.clamp(t?this.get()+1:this.get())}clamp(t){for(t=Math.trunc(t);t<2**this._size/2*(this._signed?-1:0);)t+=2**this._size;for(;t>=2**this._size/2*(this._signed?1:2);)t-=2**this._size;return t}static toNumber(t){return Types$9.isNumber(t)?t:this.constructor.toInteger(t.get()).get()}static toInteger(t){return Types$9.isNumber(t)?new this.constructor(t):t}static Int8=class extends Integer{constructor(t){super(!0,8,t)}};static Int16=class extends Integer{constructor(t){super(!0,16,t)}};static Int32=class extends Integer{constructor(t){super(!0,32,t)}};static Uint8=class extends Integer{constructor(t){super(!1,8,t)}};static Uint16=class extends Integer{constructor(t){super(!1,16,t)}};static Uint32=class extends Integer{constructor(t){super(!1,32,t)}}}class Types$9{static isUndefined(...t){return t.every(t=>void 0===t)}static isNull(...t){return t.every(t=>null===t)}static isTrue(...t){return t.every(t=>!0===t)}static isFalse(...t){return t.every(t=>!1===t)}static isBoolean(...t){return t.every(t=>"boolean"==typeof t)}static isNumber(...t){return t.every(t=>"number"==typeof t)}static isBigInt(...t){return t.every(t=>"bigint"==typeof t)}static isString(...t){return t.every(t=>"string"==typeof t)}static isFunction(...t){return t.every(t=>"function"==typeof t)}static isSymbol(...t){return t.every(t=>"symbol"==typeof t)}static isArray(...t){return t.every(t=>t instanceof Array)}static isObject(...t){return t.every(t=>t instanceof Object)}static isClass(e,...t){return t.every(t=>t instanceof e)}}var helpers={Integer:Integer,Types:Types$9},name="@onenylxus/lime",version="0.3.0",description="Mathematics computation engine",author="Lime Project Team",license="MIT",keywords=["javascript","mathematics"],main="dist/bundle.js",module$1="dist/bundle-cjs.js",browser="dist/bundle-esm.js",sideEffects=!1,dependencies={"@onenylxus/helpers":"^1.0.0"},devDependencies={"@rollup/plugin-commonjs":"^20.0.0","@rollup/plugin-json":"^4.1.0","@rollup/plugin-node-resolve":"^13.0.0",codecov:"^3.8.2",eslint:"^7.25.0","eslint-config-airbnb-base":"^14.2.1","eslint-plugin-import":"^2.24.2",husky:"^7.0.2",jest:"^27.1.0","lint-staged":"^11.1.2","prettier-eslint":"^13.0.0","prettier-eslint-cli":"^5.0.1",rimraf:"^3.0.2",rollup:"^2.56.3","rollup-plugin-node-polyfills":"^0.2.1","rollup-plugin-uglify":"^6.0.4"},scripts={lint:"prettier-eslint '**/*.js'",clean:"rimraf dist/*.js",debug:"node examples/prompt.js -q",prebuild:"yarn lint && yarn clean",build:"rollup -c",watch:"jest --config jest.config.json --watch",pretest:"yarn build",test:"jest --config jest.config.json --verbose"},husky={hooks:{"pre-commit":"yarn test"}},repository={type:"git",url:"git+https://github.com/onenylxus/lime.git"},bugs={url:"https://github.com/onenylxus/lime/issues"},homepage="https://github.com/onenylxus/lime#readme",require$$0={name:name,version:version,description:description,author:author,license:license,keywords:keywords,main:main,module:module$1,browser:browser,sideEffects:sideEffects,dependencies:dependencies,devDependencies:devDependencies,scripts:scripts,husky:husky,repository:repository,bugs:bugs,homepage:homepage};const Package=require$$0;function banner$1(){const t=[`Lime version ${Package.version}`,Package.description,`2021 ${Package.author}, ${Package.license} license`,Package.homepage.slice(0,-7)];return t.join("\n")}var banner_1=banner$1;class LimeCommand$5{constructor(t,{...e}){this.lime=t,this.name=e.hasOwnProperty("name")?e.name:this.constructor.name.slice(11),this.description=e.hasOwnProperty("description")?e.description:"",this.operations=new Map}execute(t){var e=t.split(/\s/).slice(1),t=e.length;if(!this.operations.has(t))throw new Error("error:invalidParametersInCommand");return this.operations.get(t)(...e)}}var command=LimeCommand$5;const banner=banner_1,LimeCommand$4=command;class LimeCommandAbout extends LimeCommand$4{constructor(t){super(t,{name:"about",description:"show information about the engine"}),this.operations.set(0,()=>banner())}}var about$1=LimeCommandAbout;const LimeCommand$3=command;class LimeCommandClear extends LimeCommand$3{constructor(t){super(t,{name:"clear",description:"clear variables and memory"}),this.operations.set(0,()=>(this.lime.variables=new Map,this.lime.memory=[],this.lime.store={},"Cleared"))}}var clear$1=LimeCommandClear;const LimeCommand$2=command;class LimeCommandConfig extends LimeCommand$2{constructor(t){super(t,{name:"config",description:"view and modify engine configurations"}),this.operations.set(1,t=>{if(!this.lime.config.hasOwnProperty(t))throw new Error("error:invalidConfigProperty");return`${t}: ${this.lime.config[t]}`}),this.operations.set(2,(t,e)=>{if(!this.lime.config.hasOwnProperty(t))throw new Error("error:invalidConfigProperty");var i=this.lime.config[t];return this.lime.config[t]=this.lime.direct([e]).value,`${t}: ${i} > ${this.lime.config[t]}`})}}var config$1=LimeCommandConfig;const LimeCommand$1=command;class LimeCommandHelp extends LimeCommand$1{constructor(t){super(t,{name:"help",description:"list all available commands"}),this.operations.set(0,()=>{const i=["Below is a list of available commands:"];return this.lime.module.forEach(t=>{try{var e=new t(this.lime);e instanceof LimeCommand$1&&i.push(`${e.name}: ${e.description}`)}catch(t){}}),i.join("\n")})}}var help$1=LimeCommandHelp;const Types$8=helpers["Types"],LimeCommand=command;class LimeCommandList extends LimeCommand{constructor(t){super(t,{name:"list",description:"list specified engine property"}),this.operations.set(1,t=>{if(!this.lime.hasOwnProperty(t)||Types$8.isFunction(this.lime[t]))throw new Error("error:invalidListProperty");return Types$8.isClass(Map,this.lime[t])?Object.fromEntries(this.lime[t]):this.lime[t]})}}var list$1=LimeCommandList;const Types$7=helpers["Types"];class LimeExpression$7{constructor(t,{...e}){this.lime=t,this.name=e.hasOwnProperty("name")?e.name:this.constructor.name.slice(12),this.isSimple=!e.hasOwnProperty("isSimple")||!Types$7.isBoolean(e.isSimple)||e.isSimple}}var expression=LimeExpression$7;const Types$6=helpers["Types"],LimeExpression$6=expression;class LimeExpressionArgument extends LimeExpression$6{constructor(t,...e){if(super(t,{name:"argument",isSimple:!1}),!this.lime.identify("expression")(...e)&&!Types$6.isNull(e[0]))throw new Error("issue:invalidExpressionInConstruct");this.places=e}get value(){return this.places.map(t=>t.value)}get length(){return this.isEmpty?0:this.places.length}get isEmpty(){return Types$6.isNull(this.places[0])}simplify(){return this.places.map(t=>t.simplify())}finalize(){if(this.isEmpty)throw new Error("error:emptyArgumentInFinalize");return 1===this.length?this.places[0].finalize():this.places.map(t=>t.finalize())}}var argument=LimeExpressionArgument;const LimeExpression$5=expression;class LimeExpressionBoolean extends LimeExpression$5{constructor(t,e){super(t,{name:"boolean",isSimple:!0}),this.raw=e}get value(){return!!this.raw}toInteger(){if(this.lime.config.strictBoolean)throw new Error("warn:strictBoolean");return this.lime.direct([+this.value])}simplify(){return this.lime.build("boolean")(this.value)}finalize(){return this.simplify()}print(){return this.value?"true":"false"}}var boolean=LimeExpressionBoolean;const LimeExpression$4=expression;class LimeExpressionComplex extends LimeExpression$4{constructor(t,e,i){if(super(t,{name:"complex",isSimple:!0}),!this.lime.identify("integer","rational")(e,i))throw new Error("issue:invalidExpressionInConstruct");this.rPlace=e,this.iPlace=i}get value(){return{r:this.rPlace.value,i:this.iPlace.value}}toBoolean(){return this.lime.build("boolean")(this.value.r||this.value.i)}simplify(){return this.lime.direct([this.iPlace,"==",0]).value?this.rPlace.simplify():this.lime.build("complex")(this.rPlace.simplify(),this.iPlace.simplify())}finalize(){return this.simplify()}print(){var t=this.lime.direct(["sgn","(",this.iPlace,")"]).value;return`${0===this.value.r?"":`${this.rPlace.print()}${0<t?"+":""}`}${1===this.value.i?"":-1===this.value.i?"-":this.iPlace.print()}i`}}var complex=LimeExpressionComplex;const Types$5=helpers["Types"],LimeExpression$3=expression;class LimeExpressionInteger extends LimeExpression$3{constructor(t,e){if(super(t,{name:"integer",isSimple:!0}),!Types$5.isNumber(+e))throw new Error("issue:invalidExpressionInConstruct");this.string=`${e}`}get value(){return Math.trunc(+this.string)}toBoolean(){return this.lime.build("boolean")(this.value)}toComplex(){return this.lime.build("complex")(this,this.lime.build("integer")(0))}toRational(){return this.lime.build("rational")(this,this.lime.build("integer")(1))}simplify(){return this.lime.build("integer")(this.value)}finalize(){return this.simplify()}print(){return`${this.value}`}}var integer=LimeExpressionInteger;const Types$4=helpers["Types"],LimeExpression$2=expression;class LimeExpressionMatrix extends LimeExpression$2{constructor(t,e){if(super(t,{name:"matrix",isSimple:!1}),!this.lime.identify("expression")(...e.flat())&&!Types$4.isNull(e[0][0]))throw new Error("issue:invalidExpressionInConstruct");const i=e[0].length;if(e.some(t=>t.length!==i))throw new Error("error:invalidMatrixDimensions");this.places=e}get value(){return this.places.map(t=>t.map(t=>t.value))}get row(){return this.isEmpty?0:this.places.length}get column(){return this.isEmpty?0:this.places[0].length}get size(){return this.row*this.column}get isEmpty(){return Types$4.isNull(this.places[0][0])}simplify(){return this.places=this.places.map(t=>t.map(t=>t.simplify())),this}finalize(){return this.places=this.places.map(t=>t.map(t=>t.finalize())),this}print(){let i="";if(this.lime.config.testMode){i+="[";for(let e=0;e<this.row;e++){i+=0===e?"":";";for(let t=0;t<this.column;t++)i+=(0===t?"":",")+this.places[e][t].print()}i+="]"}else{var r=this.places.map(t=>t.map(t=>t.print().length));const n=[];for(let i=0;i<this.column;i++){let e=0;for(let t=0;t<this.row;t++)e=Math.max(r[t][i],e);n.push(e)}for(let e=0;e<this.row;e++){for(let t=0;t<this.column;t++)i+=new Array(n[t]-r[e][t]+this.lime.config.tabSize+1).join(" ")+this.places[e][t].print();i+=e<this.row-1?"\n":""}}return i}}var matrix$1=LimeExpressionMatrix;const LimeExpression$1=expression;class LimeExpressionRational extends LimeExpression$1{constructor(t,e,i){if(super(t,{name:"rational",isSimple:!0}),!this.lime.identify("integer")(e,i))throw new Error("issue:invalidExpressionInConstruct");this.nPlace=e,this.dPlace=i}get value(){return{n:this.nPlace.value,d:this.dPlace.value}}toBoolean(){return this.lime.build("boolean")(this.value.n/this.value.d)}toComplex(){return this.lime.build("complex")(this,this.lime.build("integer")(0))}simplify(){var t=this.lime.direct(["gcd","(",this.nPlace,",",this.dPlace,")"]);return this.nPlace=this.lime.direct([this.nPlace,"/",t]),this.dPlace=this.lime.direct([this.dPlace,"/",t]),this.value.d<0&&(this.nPlace=this.lime.direct(["-",this.nPlace]),this.dPlace=this.lime.direct(["-",this.dPlace])),1===this.value.d?this.nPlace.simplify():this.lime.build("rational")(this.nPlace.simplify(),this.dPlace.simplify())}finalize(){return this.simplify()}print(){return`${this.nPlace.print()}/${this.dPlace.print()}`}}var rational=LimeExpressionRational;const LimeExpression=expression;class LimeExpressionVariable extends LimeExpression{constructor(t,e){super(t,{name:"variable",isSimple:!0}),this.key=e}get value(){if(!this.lime.variables.has(this.key))throw new Error("error:undefinedVariable");return this.lime.variables.get(this.key)}simplify(){return this.value.simplify()}finalize(){return this.simplify()}}var variable=LimeExpressionVariable;const Oplist$1={cond:{"b(bool,bool)":t=>t.bpi("boolean"),"b(comp,comp)":t=>t.bpi("complex"),"b(comp,{int|rat})":t=>t.lpi("complex")&&t.rpi("integer","rational"),"b(expr,expr)":t=>t.bpi("expression"),"b(int,int)":t=>t.bpi("integer"),"b(int,mat)":t=>t.lpi("integer")&&t.rpi("matrix"),"b(int,rat)":t=>t.lpi("integer")&&t.rpi("rational"),"b(mat,arg{int[1]})":t=>t.lpi("matrix")&&t.rpi("argument")&&1===t.right.length&&t.ci("integer")(...t.right.places),"b(mat,int)":t=>t.lpi("matrix")&&t.rpi("integer"),"b(mat,mat)":t=>t.bpi("matrix"),"b(mat,{comp|int|rat})":t=>t.lpi("matrix")&&t.rpi("complex","integer","rational"),"b(rat,int)":t=>t.lpi("rational")&&t.rpi("integer"),"b(rat,rat)":t=>t.bpi("rational"),"b(var,expr)":t=>t.lpi("variable")&&t.rpi("expression"),"b({comp|int|rat},mat)":t=>t.lpi("complex","integer","rational")&&t.rpi("matrix"),"b({int|rat},comp)":t=>t.lpi("integer","rational")&&t.rpi("complex"),"b({int|rat},mat)":t=>t.lpi("integer","rational")&&t.rpi("matrix"),"l(arg{expr[1]})":t=>t.lpi("argument")&&1===t.left.length&&t.ci("expression")(...t.left.places),"l(bool)":t=>t.lpi("boolean"),"l(int)":t=>t.lpi("integer"),"l(var)":t=>t.lpi("variable"),"l({comp|int|rat})":t=>t.lpi("complex","integer","rational"),"n()":()=>!0,"r(arg{})":t=>t.rpi("argument")&&t.right.isEmpty,"r(arg{comp[1]})":t=>t.rpi("argument")&&1===t.right.length&&t.ci("complex")(...t.right.places),"r(arg{expr[1]})":t=>t.rpi("argument")&&1===t.right.length&&t.ci("expression")(...t.right.places),"r(arg{expr[@]})":t=>t.rpi("argument")&&t.ci("expression")(...t.right.places),"r(arg{int[1]})":t=>t.rpi("argument")&&1===t.right.length&&t.ci("integer")(...t.right.places),"r(arg{int[2]})":t=>t.rpi("argument")&&2===t.right.length&&t.ci("integer")(...t.right.places),"r(arg{rat[1]})":t=>t.rpi("argument")&&1===t.right.length&&t.ci("rational")(...t.right.places),"r(arg{mat[1]})":t=>t.rpi("argument")&&1===t.right.length&&t.ci("matrix")(...t.right.places),"r(arg{mat[1],int[1]})":t=>t.rpi("argument")&&2===t.right.length&&t.ci("matrix")(t.right.places[0])&&t.ci("integer")(t.right.places[1]),"r(arg{mat[1],int[2]})":t=>t.rpi("argument")&&3===t.right.length&&t.ci("matrix")(t.right.places[0])&&t.ci("integer")(t.right.places[1],t.right.places[2]),"r(arg{{int|rat}[$]})":e=>e.rpi("argument")&&e.right.places.some(t=>e.ci("integer","rational")(t)),"r(bool)":t=>t.rpi("boolean"),"r(int)":t=>t.rpi("integer"),"r(mat)":t=>t.rpi("matrix"),"r(rat)":t=>t.rpi("rational"),"r(var)":t=>t.rpi("variable"),"r({comp|int|rat})":t=>t.rpi("complex","integer","rational"),"r(+)":t=>t.rpi("add"),"r(=)":t=>t.rpi("assign"),"r(&)":t=>t.rpi("bitwiseAnd"),"r(|)":t=>t.rpi("bitwiseOr"),"r(/)":t=>t.rpi("divide"),"r(^)":t=>t.rpi("exponent"),"r(!)":t=>t.rpi("factorial"),"r(>)":t=>t.rpi("greater"),"r(%)":t=>t.rpi("modulo"),"r(*)":t=>t.rpi("multiply"),"r(_-)":t=>t.rpi("negative"),"r(_+)":t=>t.rpi("positive"),"r(<)":t=>t.rpi("smaller"),"r(-)":t=>t.rpi("subtract"),"z()":t=>0===t.pos},act:{"f(==)":t=>{t.rus(t.lime.refer("=="))},"f(!==)":t=>{t.rus(t.lime.refer("!"),t.lime.refer("=="))},"f(>=)":t=>{t.rus(t.lime.refer(">="))},"f(&&)":t=>{t.rus(t.lime.refer("&&"))},"f(_!)":t=>{t.fs(t.lime.refer("_!"))},"f(||)":t=>{t.rus(t.lime.refer("||"))},"f(_-)":t=>{t.fs(t.lime.refer("_-"))},"f(!=)":t=>{t.rus(t.lime.refer("!="))},"f(_+)":t=>{t.fs(t.lime.refer("_+"))},"f(.+)":t=>{t.rus(t.lime.refer(".+"))},"f(./)":t=>{t.rus(t.lime.refer("./"))},"f(.^)":t=>{t.rus(t.lime.refer(".^"))},"f(.%)":t=>{t.rus(t.lime.refer(".%"))},"f(.*)":t=>{t.rus(t.lime.refer(".*"))},"f(.-)":t=>{t.rus(t.lime.refer(".-"))},"f(<<)":t=>{t.rus(t.lime.refer("<<"))},"f(>>)":t=>{t.rus(t.lime.refer(">>"))},"f(<=)":t=>{t.rus(t.lime.refer("<="))},"l(arg{expr[1]}->expr)":t=>{t.lps(t.left.finalize())},"l(expr->int)":t=>{t.lps(t.left.toInteger())},"l(expr->rat)":t=>{t.lps(t.left.toRational())},"l(var->expr)":t=>{t.lps(t.left.value)},"l({comp|int|rat}->bool)":t=>{t.lps(t.left.toBoolean())},"l({int|rat}->comp)":t=>{t.lps(t.left.toComplex())},"r(arg{expr[1]}->expr)":t=>{t.rps(t.right.finalize())},"r(arg{{int|rat}[$]}->arg{comp[$]})":e=>{const t=e.right;t.places=t.places.map(t=>e.ci("integer","rational")(t)?t.toComplex():t),e.rps(t)},"r(expr->int)":t=>{t.rps(t.right.toInteger())},"r(expr->rat)":t=>{t.rps(t.right.toRational())},"r(var->expr)":t=>{t.rps(t.right.value)},"r({comp|int|rat}->bool)":t=>{t.rps(t.right.toBoolean())},"r({int|rat}->comp)":t=>{t.rps(t.right.toComplex())},"r(_!)":t=>{t.rps(t.lime.refer("_!"))},"r(_-)":t=>{t.rps(t.lime.refer("_-"))},"r(_+)":t=>{t.rps(t.lime.refer("_+"))}},pair:{"cb(comp,{int|rat}->comp)":["b(comp,{int|rat})","r({int|rat}->comp)"],"cb(int->rat,rat)":["b(int,rat)","l(expr->rat)"],"cb(rat,int->rat)":["b(rat,int)","r(expr->rat)"],"cb({int|rat}->comp,comp)":["b({int|rat},comp)","l({int|rat}->comp)"],"cl(arg{expr[1]}->expr)":["l(arg{expr[1]})","l(arg{expr[1]}->expr)"],"cl(bool->int)":["l(bool)","l(expr->int)"],"cl(var->expr)":["l(var)","l(var->expr)"],"cl({comp|int|rat}->bool)":["l({comp|int|rat})","l({comp|int|rat}->bool)"],"cr(arg{expr[1]}->expr)":["r(arg{expr[1]})","r(arg{expr[1]}->expr)"],"cr(arg{{int|rat}[$]}->arg{comp[$]})":["r(arg{{int|rat}[$]})","r(arg{{int|rat}[$]}->arg{comp[$]})"],"cr(bool->int)":["r(bool)","r(expr->int)"],"cr(var->expr)":["r(var)","r(var->expr)"],"cr({comp|int|rat}->bool)":["r({comp|int|rat})","r({comp|int|rat}->bool)"],"tf(==)":["r(=)","f(==)"],"tf(!==)":["r(=)","f(!==)"],"tf(>=)":["r(=)","f(>=)"],"tf(&&)":["r(&)","f(&&)"],"tf(||)":["r(|)","f(||)"],"tf(!=)":["r(=)","f(!=)"],"tf(.+)":["r(+)","f(.+)"],"tf(./)":["r(/)","f(./)"],"tf(.^)":["r(^)","f(.^)"],"tf(.%)":["r(%)","f(.%)"],"tf(.*)":["r(*)","f(.*)"],"tf(.-)":["r(-)","f(.-)"],"tf(<<)":["r(<)","f(<<)"],"tf(>>)":["r(>)","f(>>)"],"tf(<=)":["r(=)","f(<=)"],"tr(_!)":["r(!)","r(_!)"],"tr(_+)":["r(+)","r(_+)"],"tr(_-)":["r(-)","r(_-)"],"tz(_!)":["z()","f(_!)"],"tz(_+)":["z()","f(_+)"],"tz(_-)":["z()","f(_-)"]}};var oplist=Oplist$1,require$$2$1=[["columnSplit","rowSplit"],["assign","equal","greater","greaterEqual","notEqual","smaller","smallerEqual"],["add","bitwiseAnd","bitwiseNot","bitwiseOr","logicalAnd","logicalNot","logicalOr","modulo","scalarAdd","scalarModulo","scalarSubtract","shiftLeft","shiftRight","subtract"],["divide","multiply","scalarDivide","scalarMultiply"],["exponent","scalarExponent"],["decimal","negative","positive"],["absolute","adjoint","ceiling","cofactor","combination","conjugate","determinant","factorial","fibonacci","floor","greatestCommonDivisor","identityMatrix","imaginary","index","inverse","leastCommonMultiple","maximum","mean","minimum","minor","oneMatrix","permutation","prime","product","random","range","real","reciprocal","reducedRowEchelonForm","round","sign","sum","trace","transpose","truncation","zeroMatrix"],["commonBracket","matrixBracket","omitted"]];const Types$3=helpers["Types"],Oplist=oplist,Order=require$$2$1;class LimeFunction$17{constructor(t,{...e}){this.lime=t,this.mode=e.hasOwnProperty("mode")&&["l","r","b","n"].includes(e.mode)?e.mode:"x",this.name=e.hasOwnProperty("name")?e.name:this.constructor.name.slice(12),this.operations={},this.algorithms=new Map}get order(){for(let t=0;t<Order.length;t++)if(Order[t].includes(this.name))return t;throw new Error("issue:invalidFunctionOrder")}evaluate(r){if("x"===this.mode)throw new Error("error:unmatchedBrackets");const n=this.operations[this.mode];for(let i=0;i<n.length;i++){let t,e;if(Types$3.isString(n[i])&&(t="e"===n[i][0]?Oplist.cond[n[i].substring(1)]:Oplist.cond[Oplist.pair[n[i]][0]],e="e"===n[i][0]?this.algorithms.get(n[i].substring(1)):Oplist.act[Oplist.pair[n[i]][1]]),t(r))return e(r),r}throw new Error("error:functionAgreement")}}var _function=LimeFunction$17;const LimeFunction$16=_function;class LimeFunctionAdd extends LimeFunction$16{constructor(t,e){super(t,{name:"add",mode:e}),this.operations.b=["tz(_+)","tr(_!)","tr(_+)","tr(_-)","cl(var->expr)","cr(var->expr)","cl(arg{expr[1]}->expr)","cr(arg{expr[1]}->expr)","cl(bool->int)","cr(bool->int)","cb(int->rat,rat)","cb(rat,int->rat)","cb({int|rat}->comp,comp)","cb(comp,{int|rat}->comp)","eb(int,int)","eb(rat,rat)","eb(comp,comp)","eb(mat,mat)"],this.algorithms.set("b(int,int)",t=>{t.bs(this.lime.build("integer")(t.left.value+t.right.value))}),this.algorithms.set("b(rat,rat)",t=>{t.bs(this.lime.build("rational")(this.lime.direct([t.left.nPlace,"*",t.right.dPlace,"+",t.right.nPlace,"*",t.left.dPlace]),this.lime.direct([t.left.dPlace,"*",t.right.dPlace])))}),this.algorithms.set("b(comp,comp)",t=>{t.bs(this.lime.build("complex")(this.lime.direct([t.left.rPlace,"+",t.right.rPlace]),this.lime.direct([t.left.iPlace,"+",t.right.iPlace])))}),this.algorithms.set("b(mat,mat)",i=>{if(i.left.row!==i.right.row||i.left.column!==i.right.column)throw new Error("error:invalidMatrixDimensions");const r=[];for(let e=0;e<i.left.row;e++){r.push([]);for(let t=0;t<i.left.column;t++)r[e].push(this.lime.direct([i.left.places[e][t],"+",i.right.places[e][t]]))}i.bs(this.lime.build("matrix")(r))})}}var add=LimeFunctionAdd;const LimeFunction$15=_function;class LimeFunctionDecimal extends LimeFunction$15{constructor(t,e){super(t,{name:"decimal",mode:e}),this.operations.b=["tf(.+)","tf(./)","tf(.^)","tf(.%)","tf(.*)","tf(.-)","eb(int,int)"],this.algorithms.set("b(int,int)",t=>{var e;0<t.right.value?(e=this.lime.direct([10,"^",t.right.string.length]),t.bs(this.lime.direct(["(",t.left,"*",e,"+",t.right,")","/",e]))):t.bs(t.left)})}}var decimal=LimeFunctionDecimal;const LimeFunction$14=_function;class LimeFunctionDivide extends LimeFunction$14{constructor(t,e){super(t,{name:"divide",mode:e}),this.operations.b=["tr(_!)","tr(_+)","tr(_-)","cl(var->expr)","cr(var->expr)","cl(arg{expr[1]}->expr)","cr(arg{expr[1]}->expr)","cl(bool->int)","cr(bool->int)","cb(int->rat,rat)","cb(rat,int->rat)","cb({int|rat}->comp,comp)","cb(comp,{int|rat}->comp)","eb(int,int)","eb(rat,rat)","eb(comp,comp)"],this.algorithms.set("b(int,int)",t=>{t.left.value%t.right.value==0?t.bs(this.lime.build("integer")(t.left.value/t.right.value)):t.bs(this.lime.build("rational")(t.left,t.right))}),this.algorithms.set("b(rat,rat)",t=>{t.bs(this.lime.build("rational")(this.lime.direct([t.left.nPlace,"*",t.right.dPlace]),this.lime.direct([t.left.dPlace,"*",t.right.nPlace])))}),this.algorithms.set("b(comp,comp)",t=>{t.bs(this.lime.build("complex")(this.lime.direct(["re","(",t.left,"*","conj","(",t.right,")",")","/","(",t.right,"*","conj","(",t.right,")",")"]),this.lime.direct(["im","(",t.left,"*","conj","(",t.right,")",")","/","(",t.right,"*","conj","(",t.right,")",")"])))})}}var divide=LimeFunctionDivide;const LimeFunction$13=_function;class LimeFunctionExponent extends LimeFunction$13{constructor(t,e){super(t,{name:"exponent",mode:e}),this.operations.b=["tr(_!)","tr(_+)","tr(_-)","cl(var->expr)","cr(var->expr)","cl(arg{expr[1]}->expr)","cr(arg{expr[1]}->expr)","cl(bool->int)","cr(bool->int)","eb(int,int)","eb(rat,int)"],this.algorithms.set("b(int,int)",t=>{if(0<=t.right.value){if(0===t.left.value&&0===t.right.value)throw new Error("warn:zeroExponentOfZero");t.bs(this.lime.build("integer")(t.left.value**t.right.value))}else t.bs(this.lime.build("rational")(this.lime.direct([1]),this.lime.direct([t.left,"^","-",t.right])))}),this.algorithms.set("b(rat,int)",t=>{0<=t.right.value?t.bs(this.lime.build("rational")(this.lime.direct([t.left.nPlace,"^",t.right]),this.lime.direct([t.left.dPlace,"^",t.right]))):t.bs(this.lime.build("rational")(this.lime.direct([t.left.dPlace,"^","-",t.right]),this.lime.direct([t.left.nPlace,"^","-",t.right])))})}}var exponent=LimeFunctionExponent;const LimeFunction$12=_function;class LimeFunctionModulo extends LimeFunction$12{constructor(t,e){super(t,{name:"modulo",mode:e}),this.operations.b=["tr(_!)","tr(_+)","tr(_-)","cl(var->expr)","cr(var->expr)","cl(arg{expr[1]}->expr)","cr(arg{expr[1]}->expr)","cl(bool->int)","cr(bool->int)","eb(int,int)"],this.algorithms.set("b(int,int)",t=>{t.bs(this.lime.build("integer")(t.left.value%t.right.value))})}}var modulo=LimeFunctionModulo;const LimeFunction$11=_function;class LimeFunctionMultiply extends LimeFunction$11{constructor(t,e){super(t,{name:"multiply",mode:e}),this.operations.b=["tr(_!)","tr(_+)","tr(_-)","cl(var->expr)","cr(var->expr)","cl(arg{expr[1]}->expr)","cr(arg{expr[1]}->expr)","cl(bool->int)","cr(bool->int)","cb(int->rat,rat)","cb(rat,int->rat)","cb({int|rat}->comp,comp)","cb(comp,{int|rat}->comp)","eb(int,int)","eb(rat,rat)","eb(comp,comp)","eb(mat,mat)"],this.algorithms.set("b(int,int)",t=>{t.bs(this.lime.build("integer")(t.left.value*t.right.value))}),this.algorithms.set("b(rat,rat)",t=>{t.bs(this.lime.build("rational")(this.lime.direct([t.left.nPlace,"*",t.right.nPlace]),this.lime.direct([t.left.dPlace,"*",t.right.dPlace])))}),this.algorithms.set("b(comp,comp)",t=>{t.bs(this.lime.build("complex")(this.lime.direct([t.left.rPlace,"*",t.right.rPlace,"-",t.left.iPlace,"*",t.right.iPlace]),this.lime.direct([t.left.rPlace,"*",t.right.iPlace,"+",t.left.iPlace,"*",t.right.rPlace])))}),this.algorithms.set("b(mat,mat)",n=>{if(n.left.column!==n.right.row)throw new Error("error:invalidMatrixDimensions");const t=[];for(let r=0;r<n.left.row;r++){t.push([]);for(let i=0;i<n.right.column;i++){let e=this.lime.direct([0]);for(let t=0;t<n.right.row;t++)e=this.lime.direct([e,"+",n.left.places[r][t],"*",n.right.places[t][i]]);t[r].push(e)}}n.bs(this.lime.build("matrix")(t))})}}var multiply=LimeFunctionMultiply;const LimeFunction$10=_function;class LimeFunctionNegative extends LimeFunction$10{constructor(t,e){super(t,{name:"negative",mode:e}),this.operations.r=["tr(_!)","tr(_+)","tr(_-)","cr(var->expr)","cr(arg{expr[1]}->expr)","cr(bool->int)","er({comp|int|rat})","er(mat)","er(_+)","er(_-)"],this.algorithms.set("r({comp|int|rat})",t=>{t.rus(this.lime.direct([-1,"*",t.right]))}),this.algorithms.set("r(mat)",t=>{t.rus(this.lime.direct([-1,".*",t.right]))}),this.algorithms.set("r(_+)",t=>{t.rus(this.lime.refer("_-"))}),this.algorithms.set("r(_-)",t=>{t.rus(this.lime.refer("_+"))})}}var negative=LimeFunctionNegative;const LimeFunction$$=_function;class LimeFunctionPositive extends LimeFunction$${constructor(t,e){super(t,{name:"positive",mode:e}),this.operations.r=["tr(_!)","tr(_+)","tr(_-)","cr(var->expr)","cr(arg{expr[1]}->expr)","cr(bool->int)","er({comp|int|rat})","er(mat)","er(_+)","er(_-)"],this.algorithms.set("r({comp|int|rat})",t=>{t.rus(this.lime.direct([1,"*",t.right]))}),this.algorithms.set("r(mat)",t=>{t.rus(this.lime.direct([1,".*",t.right]))}),this.algorithms.set("r(_+)",t=>{t.rus(this.lime.refer("_+"))}),this.algorithms.set("r(_-)",t=>{t.rus(this.lime.refer("_-"))})}}var positive=LimeFunctionPositive;const LimeFunction$_=_function;class LimeFunctionScalarAdd extends LimeFunction$_{constructor(t,e){super(t,{name:"scalarAdd",mode:e}),this.operations.b=["cl(arg{expr[1]}->expr)","cr(arg{expr[1]}->expr)","cl(bool->int)","cr(bool->int)","eb(mat,mat)","eb(mat,{comp|int|rat})","eb({comp|int|rat},mat)"],this.algorithms.set("b(mat,mat)",t=>{t.bs(this.lime.direct([t.left,"+",t.right]))}),this.algorithms.set("b(mat,{comp|int|rat})",i=>{const r=[];for(let e=0;e<i.left.row;e++){r.push([]);for(let t=0;t<i.left.column;t++)r[e].push(this.lime.direct([i.left.places[e][t],"+",i.right]))}i.bs(this.lime.build("matrix")(r))}),this.algorithms.set("b({comp|int|rat},mat)",i=>{const r=[];for(let e=0;e<i.right.row;e++){r.push([]);for(let t=0;t<i.right.column;t++)r[e].push(this.lime.direct([i.left,"+",i.right.places[e][t]]))}i.bs(this.lime.build("matrix")(r))})}}var scalarAdd=LimeFunctionScalarAdd;const LimeFunction$Z=_function;class LimeFunctionScalarDivide extends LimeFunction$Z{constructor(t,e){super(t,{name:"scalarDivide",mode:e}),this.operations.b=["cl(arg{expr[1]}->expr)","cr(arg{expr[1]}->expr)","cl(bool->int)","cr(bool->int)","eb(mat,mat)","eb(mat,{comp|int|rat})","eb({comp|int|rat},mat)"],this.algorithms.set("b(mat,mat)",i=>{if(i.left.row!==i.right.row||i.left.column!==i.right.column)throw new Error("error:invalidMatrixDimensions");const r=[];for(let e=0;e<i.left.row;e++){r.push([]);for(let t=0;t<i.left.column;t++)r[e].push(this.lime.direct([i.left.places[e][t],"/",i.right.places[e][t]]))}i.bs(this.lime.build("matrix")(r))}),this.algorithms.set("b(mat,{comp|int|rat})",i=>{const r=[];for(let e=0;e<i.left.row;e++){r.push([]);for(let t=0;t<i.left.column;t++)r[e].push(this.lime.direct([i.left.places[e][t],"/",i.right]))}i.bs(this.lime.build("matrix")(r))}),this.algorithms.set("b({comp|int|rat},mat)",i=>{const r=[];for(let e=0;e<i.right.row;e++){r.push([]);for(let t=0;t<i.right.column;t++)r[e].push(this.lime.direct([i.left,"/",i.right.places[e][t]]))}i.bs(this.lime.build("matrix")(r))})}}var scalarDivide=LimeFunctionScalarDivide;const LimeFunction$Y=_function;class LimeFunctionScalarExponent extends LimeFunction$Y{constructor(t,e){super(t,{name:"scalarExponent",mode:e}),this.operations.b=["cl(arg{expr[1]}->expr)","cr(arg{expr[1]}->expr)","cl(bool->int)","cr(bool->int)","eb(mat,int)","eb(mat,mat)","eb({int|rat},mat)"],this.algorithms.set("b(mat,int)",i=>{const r=[];for(let e=0;e<i.left.row;e++){r.push([]);for(let t=0;t<i.left.column;t++)r[e].push(this.lime.direct([i.left.places[e][t],"^",i.right]))}i.bs(this.lime.build("matrix")(r))}),this.algorithms.set("b(mat,mat)",i=>{if(i.left.row!==i.right.row||i.left.column!==i.right.column)throw new Error("error:invalidMatrixDimensions");const r=[];for(let e=0;e<i.left.row;e++){r.push([]);for(let t=0;t<i.left.column;t++)r[e].push(this.lime.direct([i.left.places[e][t],"^",i.right.places[e][t]]))}i.bs(this.lime.build("matrix")(r))}),this.algorithms.set("b({int|rat},mat)",i=>{const r=[];for(let e=0;e<i.right.row;e++){r.push([]);for(let t=0;t<i.right.column;t++)r[e].push(this.lime.direct([i.left,"^",i.right.places[e][t]]))}i.bs(this.lime.build("matrix")(r))})}}var scalarExponent=LimeFunctionScalarExponent;const LimeFunction$X=_function;class LimeFunctionScalarModulo extends LimeFunction$X{constructor(t,e){super(t,{name:"scalarModulo",mode:e}),this.operations.b=["cl(arg{expr[1]}->expr)","cr(arg{expr[1]}->expr)","cl(bool->int)","cr(bool->int)","eb(int,mat)","eb(mat,int)","eb(mat,mat)"],this.algorithms.set("b(int,mat)",i=>{const r=[];for(let e=0;e<i.right.row;e++){r.push([]);for(let t=0;t<i.right.column;t++)r[e].push(this.lime.direct([i.left,"%",i.right.places[e][t]]))}i.bs(this.lime.build("matrix")(r))}),this.algorithms.set("b(mat,int)",i=>{const r=[];for(let e=0;e<i.left.row;e++){r.push([]);for(let t=0;t<i.left.column;t++)r[e].push(this.lime.direct([i.left.places[e][t],"%",i.right]))}i.bs(this.lime.build("matrix")(r))}),this.algorithms.set("b(mat,mat)",i=>{if(i.left.row!==i.right.row||i.left.column!==i.right.column)throw new Error("error:invalidMatrixDimensions");const r=[];for(let e=0;e<i.left.row;e++){r.push([]);for(let t=0;t<i.left.column;t++)r[e].push(this.lime.direct([i.left.places[e][t],"%",i.right.places[e][t]]))}i.bs(this.lime.build("matrix")(r))})}}var scalarModulo=LimeFunctionScalarModulo;const LimeFunction$W=_function;class LimeFunctionScalarMultiply extends LimeFunction$W{constructor(t,e){super(t,{name:"scalarMultiply",mode:e}),this.operations.b=["cl(arg{expr[1]}->expr)","cr(arg{expr[1]}->expr)","cl(bool->int)","cr(bool->int)","eb(mat,mat)","eb(mat,{comp|int|rat})","eb({comp|int|rat},mat)"],this.algorithms.set("b(mat,mat)",i=>{if(i.left.row!==i.right.row||i.left.column!==i.right.column)throw new Error("error:invalidMatrixDimensions");const r=[];for(let e=0;e<i.left.row;e++){r.push([]);for(let t=0;t<i.left.column;t++)r[e].push(this.lime.direct([i.left.places[e][t],"*",i.right.places[e][t]]))}i.bs(this.lime.build("matrix")(r))}),this.algorithms.set("b(mat,{comp|int|rat})",i=>{const r=[];for(let e=0;e<i.left.row;e++){r.push([]);for(let t=0;t<i.left.column;t++)r[e].push(this.lime.direct([i.left.places[e][t],"*",i.right]))}i.bs(this.lime.build("matrix")(r))}),this.algorithms.set("b({comp|int|rat},mat)",i=>{const r=[];for(let e=0;e<i.right.row;e++){r.push([]);for(let t=0;t<i.right.column;t++)r[e].push(this.lime.direct([i.left,"*",i.right.places[e][t]]))}i.bs(this.lime.build("matrix")(r))})}}var scalarMultiply=LimeFunctionScalarMultiply;const LimeFunction$V=_function;class LimeFunctionScalarSubtract extends LimeFunction$V{constructor(t,e){super(t,{name:"scalarSubtract",mode:e}),this.operations.b=["cl(arg{expr[1]}->expr)","cr(arg{expr[1]}->expr)","cl(bool->int)","cr(bool->int)","eb(mat,mat)","eb(mat,{comp|int|rat})","eb({comp|int|rat},mat)"],this.algorithms.set("b(mat,mat)",t=>{t.bs(this.lime.direct([t.left,"-",t.right]))}),this.algorithms.set("b(mat,{comp|int|rat})",i=>{const r=[];for(let e=0;e<i.left.row;e++){r.push([]);for(let t=0;t<i.left.column;t++)r[e].push(this.lime.direct([i.left.places[e][t],"-",i.right]))}i.bs(this.lime.build("matrix")(r))}),this.algorithms.set("b({comp|int|rat},mat)",i=>{const r=[];for(let e=0;e<i.right.row;e++){r.push([]);for(let t=0;t<i.right.column;t++)r[e].push(this.lime.direct([i.left,"-",i.right.places[e][t]]))}i.bs(this.lime.build("matrix")(r))})}}var scalarSubtract=LimeFunctionScalarSubtract;const LimeFunction$U=_function;class LimeFunctionSubtract extends LimeFunction$U{constructor(t,e){super(t,{name:"subtract",mode:e}),this.operations.b=["tz(_-)","tr(_!)","tr(_+)","tr(_-)","cl(var->expr)","cr(var->expr)","cl(arg{expr[1]}->expr)","cr(arg{expr[1]}->expr)","cl(bool->int)","cr(bool->int)","cb(int->rat,rat)","cb(rat,int->rat)","cb({int|rat}->comp,comp)","cb(comp,{int|rat}->comp)","eb(int,int)","eb(rat,rat)","eb(comp,comp)","eb(mat,mat)"],this.algorithms.set("b(int,int)",t=>{t.bs(this.lime.build("integer")(t.left.value-t.right.value))}),this.algorithms.set("b(rat,rat)",t=>{t.bs(this.lime.build("rational")(this.lime.direct([t.left.nPlace,"*",t.right.dPlace,"-",t.right.nPlace,"*",t.left.dPlace]),this.lime.direct([t.left.dPlace,"*",t.right.dPlace])))}),this.algorithms.set("b(comp,comp)",t=>{t.bs(this.lime.build("complex")(this.lime.direct([t.left.rPlace,"-",t.right.rPlace]),this.lime.direct([t.left.iPlace,"-",t.right.iPlace])))}),this.algorithms.set("b(mat,mat)",i=>{if(i.left.row!==i.right.row||i.left.column!==i.right.column)throw new Error("error:invalidMatrixDimensions");const r=[];for(let e=0;e<i.left.row;e++){r.push([]);for(let t=0;t<i.left.column;t++)r[e].push(this.lime.direct([i.left.places[e][t],"-",i.right.places[e][t]]))}i.bs(this.lime.build("matrix")(r))})}}var subtract=LimeFunctionSubtract;const LimeFunction$T=_function;class LimeFunctionBitwiseAnd extends LimeFunction$T{constructor(t,e){super(t,{name:"bitwiseAnd",mode:e}),this.operations.b=["tf(&&)","tr(_!)","tr(_+)","tr(_-)","cl(var->expr)","cr(var->expr)","cl(arg{expr[1]}->expr)","cr(arg{expr[1]}->expr)","cl(bool->int)","cr(bool->int)","eb(int,int)"],this.algorithms.set("b(int,int)",t=>{t.bs(this.lime.direct([t.left.value&t.right.value]))})}}var bitwiseAnd=LimeFunctionBitwiseAnd;const LimeFunction$S=_function;class LimeFunctionBitwiseNot extends LimeFunction$S{constructor(t,e){super(t,{name:"bitwiseNot",mode:e}),this.operations.r=["tr(_!)","tr(_+)","tr(_-)","cr(var->expr)","cr(arg{expr[1]}->expr)","cr(bool->int)","er(int)"],this.algorithms.set("r(int)",t=>{t.rus(this.lime.direct([~t.right.value]))})}}var bitwiseNot=LimeFunctionBitwiseNot;const LimeFunction$R=_function;class LimeFunctionBitwiseOr extends LimeFunction$R{constructor(t,e){super(t,{name:"bitwiseOr",mode:e}),this.operations.b=["tf(||)","tr(_!)","tr(_+)","tr(_-)","cl(var->expr)","cr(var->expr)","cl(arg{expr[1]}->expr)","cr(arg{expr[1]}->expr)","cl(bool->int)","cr(bool->int)","eb(int,int)"],this.algorithms.set("b(int,int)",t=>{t.bs(this.lime.direct([t.left.value|t.right.value]))})}}var bitwiseOr=LimeFunctionBitwiseOr;const LimeFunction$Q=_function;class LimeFunctionShiftLeft extends LimeFunction$Q{constructor(t,e){super(t,{name:"shiftLeft",mode:e}),this.operations.b=["tr(_!)","tr(_+)","tr(_-)","cl(var->expr)","cr(var->expr)","cl(arg{expr[1]}->expr)","cr(arg{expr[1]}->expr)","cl(bool->int)","cr(bool->int)","eb(int,int)"],this.algorithms.set("b(int,int)",t=>{t.bs(this.lime.direct([t.left.value<<t.right.value]))})}}var shiftLeft=LimeFunctionShiftLeft;const LimeFunction$P=_function;class LimeFunctionShiftRight extends LimeFunction$P{constructor(t,e){super(t,{name:"shiftRight",mode:e}),this.operations.b=["tr(_!)","tr(_+)","tr(_-)","cl(var->expr)","cr(var->expr)","cl(arg{expr[1]}->expr)","cr(arg{expr[1]}->expr)","cl(bool->int)","cr(bool->int)","eb(int,int)"],this.algorithms.set("b(int,int)",t=>{t.bs(this.lime.direct([t.left.value>>t.right.value]))})}}var shiftRight=LimeFunctionShiftRight;const LimeFunction$O=_function;class LimeFunctionEqual extends LimeFunction$O{constructor(t,e){super(t,{name:"equal",mode:e}),this.operations.b=["tr(_!)","tr(_+)","tr(_-)","cl(var->expr)","cr(var->expr)","cl(arg{expr[1]}->expr)","cr(arg{expr[1]}->expr)","cl(bool->int)","cr(bool->int)","cb(int->rat,rat)","cb(rat,int->rat)","eb(int,int)","eb(rat,rat)"],this.algorithms.set("b(int,int)",t=>{t.bs(this.lime.build("boolean")(t.left.value===t.right.value))}),this.algorithms.set("b(rat,rat)",t=>{t.bs(this.lime.direct([t.left.nPlace,"*",t.right.dPlace,"==",t.right.nPlace,"*",t.left.dPlace]))})}}var equal=LimeFunctionEqual;const LimeFunction$N=_function;class LimeFunctionGreater extends LimeFunction$N{constructor(t,e){super(t,{name:"greater",mode:e}),this.operations.b=["tf(>=)","tf(>>)","tr(_!)","tr(_+)","tr(_-)","cl(var->expr)","cr(var->expr)","cl(arg{expr[1]}->expr)","cr(arg{expr[1]}->expr)","cl(bool->int)","cr(bool->int)","cb(int->rat,rat)","cb(rat,int->rat)","eb(int,int)","eb(rat,rat)"],this.algorithms.set("b(int,int)",t=>{t.bs(this.lime.build("boolean")(t.left.value>t.right.value))}),this.algorithms.set("b(rat,rat)",t=>{t.bs(this.lime.direct([t.left.nPlace,"*",t.right.dPlace,">",t.right.nPlace,"*",t.left.dPlace]))})}}var greater=LimeFunctionGreater;const LimeFunction$M=_function;class LimeFunctionGreaterEqual extends LimeFunction$M{constructor(t,e){super(t,{name:"greaterEqual",mode:e}),this.operations.b=["tr(_!)","tr(_+)","tr(_-)","cl(var->expr)","cr(var->expr)","cl(arg{expr[1]}->expr)","cr(arg{expr[1]}->expr)","cl(bool->int)","cr(bool->int)","cb(int->rat,rat)","cb(rat,int->rat)","eb(int,int)","eb(rat,rat)"],this.algorithms.set("b(int,int)",t=>{t.bs(this.lime.build("boolean")(t.left.value>=t.right.value))}),this.algorithms.set("b(rat,rat)",t=>{t.bs(this.lime.direct([t.left.nPlace,"*",t.right.dPlace,">=",t.right.nPlace,"*",t.left.dPlace]))})}}var greaterEqual=LimeFunctionGreaterEqual;const LimeFunction$L=_function;class LimeFunctionNotEqual extends LimeFunction$L{constructor(t,e){super(t,{name:"notEqual",mode:e}),this.operations.b=["tf(!==)","tr(_!)","tr(_+)","tr(_-)","cl(var->expr)","cr(var->expr)","cl(arg{expr[1]}->expr)","cr(arg{expr[1]}->expr)","cl(bool->int)","cr(bool->int)","cb(int->rat,rat)","cb(rat,int->rat)","eb(int,int)","eb(rat,rat)"],this.algorithms.set("b(int,int)",t=>{t.bs(this.lime.build("boolean")(t.left.value!==t.right.value))}),this.algorithms.set("b(rat,rat)",t=>{t.bs(this.lime.direct([t.left.nPlace,"*",t.right.dPlace,"!=",t.right.nPlace,"*",t.left.dPlace]))})}}var notEqual=LimeFunctionNotEqual;const LimeFunction$K=_function;class LimeFunctionSmaller extends LimeFunction$K{constructor(t,e){super(t,{name:"smaller",mode:e}),this.operations.b=["tf(<=)","tf(<<)","tr(_!)","tr(_+)","tr(_-)","cl(var->expr)","cr(var->expr)","cl(arg{expr[1]}->expr)","cr(arg{expr[1]}->expr)","cl(bool->int)","cr(bool->int)","cb(int->rat,rat)","cb(rat,int->rat)","eb(int,int)","eb(rat,rat)"],this.algorithms.set("b(int,int)",t=>{t.bs(this.lime.build("boolean")(t.left.value<t.right.value))}),this.algorithms.set("b(rat,rat)",t=>{t.bs(this.lime.direct([t.left.nPlace,"*",t.right.dPlace,"<",t.right.nPlace,"*",t.left.dPlace]))})}}var smaller=LimeFunctionSmaller;const LimeFunction$J=_function;class LimeFunctionSmallerEqual extends LimeFunction$J{constructor(t,e){super(t,{name:"smallerEqual",mode:e}),this.operations.b=["tr(_!)","tr(_+)","tr(_-)","cl(var->expr)","cr(var->expr)","cl(arg{expr[1]}->expr)","cr(arg{expr[1]}->expr)","cl(bool->int)","cr(bool->int)","cb(int->rat,rat)","cb(rat,int->rat)","eb(int,int)","eb(rat,rat)"],this.algorithms.set("b(int,int)",t=>{t.bs(this.lime.build("boolean")(t.left.value<=t.right.value))}),this.algorithms.set("b(rat,rat)",t=>{t.bs(this.lime.direct([t.left.nPlace,"*",t.right.dPlace,"<=",t.right.nPlace,"*",t.left.dPlace]))})}}var smallerEqual=LimeFunctionSmallerEqual;const LimeFunction$I=_function;class LimeFunctionConjugate extends LimeFunction$I{constructor(t,e){super(t,{name:"conjugate",mode:e}),this.operations.r=["cr(arg{{int|rat}[$]}->arg{comp[$]})","er(arg{comp[1]})"],this.algorithms.set("r(arg{comp[1]})",t=>{t.rus(this.lime.build("complex")(t.right.places[0].rPlace,this.lime.direct(["-",t.right.places[0].iPlace])))})}}var conjugate=LimeFunctionConjugate;const LimeFunction$H=_function;class LimeFunctionImaginary extends LimeFunction$H{constructor(t,e){super(t,{name:"imaginary",mode:e}),this.operations.r=["cr(arg{{int|rat}[$]}->arg{comp[$]})","er(arg{comp[1]})"],this.algorithms.set("r(arg{comp[1]})",t=>{t.rus(this.lime.direct([t.right.places[0].iPlace]))})}}var imaginary=LimeFunctionImaginary;const LimeFunction$G=_function;class LimeFunctionReal extends LimeFunction$G{constructor(t,e){super(t,{name:"real",mode:e}),this.operations.r=["cr(arg{{int|rat}[$]}->arg{comp[$]})","er(arg{comp[1]})"],this.algorithms.set("r(arg{comp[1]})",t=>{t.rus(this.lime.direct([t.right.places[0].rPlace]))})}}var real=LimeFunctionReal;const LimeFunction$F=_function;class LimeFunctionCombination extends LimeFunction$F{constructor(t,e){super(t,{name:"combination",mode:e}),this.operations.r=["er(arg{int[2]})"],this.algorithms.set("r(arg{int[2]})",t=>{var[e,i]=t.right.places;if(e.value<i.value)throw new Error("error:invalidArgumentLogic");t.rus(this.lime.direct(["npr","(",e,",",i,")","/",i,"!"]))})}}var combination=LimeFunctionCombination;const LimeFunction$E=_function;class LimeFunctionFactorial extends LimeFunction$E{constructor(t,e){super(t,{name:"factorial",mode:e}),this.operations.l=["tz(_!)","tf(!=)","cl(var->expr)","cl(arg{expr[1]}->expr)","cl(bool->int)","el(int)"],this.algorithms.set("l(int)",t=>{if(t.left.value<0)throw new Error("warn:negativeFactorial");0<t.left.value?t.lus(this.lime.direct([t.left,"*","(",t.left,"-",1,")","!"])):t.lus(this.lime.direct([1]))})}}var factorial=LimeFunctionFactorial;const LimeFunction$D=_function;class LimeFunctionPermutation extends LimeFunction$D{constructor(t,e){super(t,{name:"permutation",mode:e}),this.operations.r=["er(arg{int[2]})"],this.algorithms.set("r(arg{int[2]})",t=>{var[e,i]=t.right.places;if(e.value<i.value)throw new Error("error:invalidArgumentLogic");t.rus(this.lime.direct([e,"!","/","(",e,"-",i,")","!"]))})}}var permutation=LimeFunctionPermutation;const LimeFunction$C=_function;class LimeFunctionLogicalAnd extends LimeFunction$C{constructor(t,e){super(t,{name:"logicalAnd",mode:e}),this.operations.b=["tr(_!)","tr(_+)","tr(_-)","cl(var->expr)","cr(var->expr)","cl(arg{expr[1]}->expr)","cr(arg{expr[1]}->expr)","cl({comp|int|rat}->bool)","cr({comp|int|rat}->bool)","eb(bool,bool)"],this.algorithms.set("b(bool,bool)",t=>{t.bs(this.lime.build("boolean")(t.left.value&&t.right.value))})}}var logicalAnd=LimeFunctionLogicalAnd;const LimeFunction$B=_function;class LimeFunctionLogicalNot extends LimeFunction$B{constructor(t,e){super(t,{name:"logicalNot",mode:e}),this.operations.r=["tr(_!)","tr(_+)","tr(_-)","cr(var->expr)","cr(arg{expr[1]}->expr)","cr({comp|int|rat}->bool)","er(bool)"],this.algorithms.set("r(bool)",t=>{t.rus(this.lime.build("boolean")(!t.right.value))})}}var logicalNot=LimeFunctionLogicalNot;const LimeFunction$A=_function;class LimeFunctionLogicalOr extends LimeFunction$A{constructor(t,e){super(t,{name:"logicalOr",mode:e}),this.operations.b=["tr(_!)","tr(_+)","tr(_-)","cl(var->expr)","cr(var->expr)","cl(arg{expr[1]}->expr)","cr(arg{expr[1]}->expr)","cl({comp|int|rat}->bool)","cr({comp|int|rat}->bool)","eb(bool,bool)"],this.algorithms.set("b(bool,bool)",t=>{t.bs(this.lime.build("boolean")(t.left.value||t.right.value))})}}var logicalOr=LimeFunctionLogicalOr;const LimeFunction$z=_function;class LimeFunctionAdjoint extends LimeFunction$z{constructor(t,e){super(t,{name:"adjoint",mode:e}),this.operations.r=["er(arg{mat[1]})"],this.algorithms.set("r(arg{mat[1]})",t=>{t.rus(this.lime.direct(["transpose","(","cof","(",t.right.places[0],")",")"]))})}}var adjoint=LimeFunctionAdjoint;const LimeFunction$y=_function;class LimeFunctionCofactor extends LimeFunction$y{constructor(t,e){super(t,{name:"cofactor",mode:e}),this.operations.r=["er(arg{mat[1]})"],this.algorithms.set("r(arg{mat[1]})",t=>{var i=t.right.places[0];const r=[];for(let e=0;e<i.column;e++){r.push([]);for(let t=0;t<i.row;t++)r[e].push(this.lime.direct(["det","(","minor","(",i,",",e+1,",",t+1,")",")","*",(t+e)%2?-1:1]))}t.rus(this.lime.build("matrix")(r))})}}var cofactor=LimeFunctionCofactor;const LimeFunction$x=_function;class LimeFunctionDeterminant extends LimeFunction$x{constructor(t,e){super(t,{name:"determinant",mode:e}),this.operations.r=["er(arg{mat[1]})"],this.algorithms.set("r(arg{mat[1]})",t=>{var e=t.right.places[0];if(e.row!==e.column)throw new Error("error:invalidMatrixDimensions");let i=this.lime.direct([0]);if(1<e.row)for(let t=0;t<e.row;t++)i=this.lime.direct([i,t%2?"-":"+",e.places[0][t],"*","det","(","minor","(",e,",",1,",",t+1,")",")"]);else i=this.lime.direct([i,"+",e.places[0][0]]);t.rus(i)})}}var determinant=LimeFunctionDeterminant;const LimeFunction$w=_function;class LimeFunctionIdentityMatrix extends LimeFunction$w{constructor(t,e){super(t,{name:"identityMatrix",mode:e}),this.operations.r=["er(arg{int[1]})"],this.algorithms.set("r(arg{int[1]})",i=>{const r=[];for(let e=0;e<i.right.value[0];e++){r.push([]);for(let t=0;t<i.right.value[0];t++)r[e].push(this.lime.direct([t===e?1:0]))}i.rus(this.lime.build("matrix")(r))})}}var identityMatrix=LimeFunctionIdentityMatrix;const LimeFunction$v=_function;class LimeFunctionIndex extends LimeFunction$v{constructor(t,e){super(t,{name:"index",mode:e}),this.operations.r=["er(arg{mat[1],int[1]})","er(arg{mat[1],int[2]})"],this.algorithms.set("r(arg{mat[1],int[1]})",t=>{if(t.right.value[1]<=0||t.right.value[1]>t.right.places[0].size)throw new Error("error:invalidMatrixDimensions");var e=Math.floor((t.right.value[1]-1)/t.right.places[0].column),i=(t.right.value[1]-1)%t.right.places[0].column;t.rus(t.right.places[0].places[e][i])}),this.algorithms.set("r(arg{mat[1],int[2]})",t=>{if(t.right.value[1]<=0||t.right.value[1]>t.right.places[0].row||t.right.value[2]<=0||t.right.value[2]>t.right.places[0].column)throw new Error("error:invalidMatrixDimensions");t.rus(t.right.places[0].places[t.right.value[1]-1][t.right.value[2]-1])})}}var matrix=LimeFunctionIndex;const LimeFunction$u=_function;class LimeFunctionInverse extends LimeFunction$u{constructor(t,e){super(t,{name:"inverse",mode:e}),this.operations.r=["er(arg{mat[1]})"],this.algorithms.set("r(arg{mat[1]})",t=>{var e=this.lime.direct(["det","(",t.right.places[0],")"]);if(0===e.value)throw new Error("error:zeroMatrixDeterminant");t.rus(this.lime.direct(["adj","(",t.right.places[0],")","./",e]))})}}var inverse=LimeFunctionInverse;const LimeFunction$t=_function;class LimeFunctionMinor extends LimeFunction$t{constructor(t,e){super(t,{name:"minor",mode:e}),this.operations.r=["er(arg{mat[1],int[2]})"],this.algorithms.set("r(arg{mat[1],int[2]})",i=>{if(i.right.value[1]<=0||i.right.value[1]>i.right.places[0].row||i.right.value[2]<=0||i.right.value[2]>i.right.places[0].column)throw new Error("error:invalidMatrixDimensions");const r=[];for(let e=0;e<i.right.places[0].row;e++)if(e!==i.right.value[1]-1){r.push([]);for(let t=0;t<i.right.places[0].column;t++)t!==i.right.value[2]-1&&r[r.length-1].push(i.right.places[0].places[e][t])}i.rus(this.lime.build("matrix")(r))})}}var minor$1=LimeFunctionMinor;const LimeFunction$s=_function;class LimeFunctionOneMatrix extends LimeFunction$s{constructor(t,e){super(t,{name:"oneMatrix",mode:e}),this.operations.r=["er(arg{int[1]})","er(arg{int[2]})"],this.algorithms.set("r(arg{int[1]})",i=>{const r=[];for(let e=0;e<i.right.value[0];e++){r.push([]);for(let t=0;t<i.right.value[0];t++)r[e].push(this.lime.direct([1]))}i.rus(this.lime.build("matrix")(r))}),this.algorithms.set("r(arg{int[2]})",i=>{const r=[];for(let e=0;e<i.right.value[0];e++){r.push([]);for(let t=0;t<i.right.value[1];t++)r[e].push(this.lime.direct([1]))}i.rus(this.lime.build("matrix")(r))})}}var oneMatrix=LimeFunctionOneMatrix;const LimeFunction$r=_function;class LimeFunctionReducedRowEchelonForm extends LimeFunction$r{constructor(t,e){super(t,{name:"reducedRowEchelonForm",mode:e}),this.operations.r=["er(arg{mat[1]})"],this.algorithms.set("r(arg{mat[1]})",t=>{const i=t.right.places[0];let e=0,r=i.row;for(;e<r;)i.places[e].every(t=>this.lime.direct([t,"==",0]).value)?i.places.splice(--r,0,...i.places.splice(e,1)):e++;let n=e=0,s=0;for(;n<i.column&&s<r;)if(e>=r)n++,e=s;else if(this.lime.direct([i.places[e][n],"!=",0]).value){i.places.splice(s,0,...i.places.splice(e,1)),i.places[s]=i.places[s].map(t=>this.lime.direct([t,"/",i.places[s][n]]));for(let e=0;e<r;e++)if(e!==s){var o=i.places[e][n];for(let t=n;t<i.column;t++)i.places[e][t]=this.lime.direct([i.places[e][t],"-",i.places[s][t],"*",o])}s++,e=r}else e++;const a=[];for(let e=0;e<i.row;e++){a.push([]);for(let t=0;t<i.column;t++)a[e].push(i.places[e][t])}t.rus(this.lime.build("matrix")(a))})}}var reducedRowEchelonForm=LimeFunctionReducedRowEchelonForm;const LimeFunction$q=_function;class LimeFunctionTrace extends LimeFunction$q{constructor(t,e){super(t,{name:"trace",mode:e}),this.operations.r=["er(arg{mat[1]})"],this.algorithms.set("r(arg{mat[1]})",t=>{var e=t.right.places[0];if(e.row!==e.column)throw new Error("error:invalidMatrixDimensions");let i=this.lime.direct([0]);for(let t=0;t<e.row;t++)i=this.lime.direct([i,"+",e.places[t][t]]);t.rus(i)})}}var trace=LimeFunctionTrace;const LimeFunction$p=_function;class LimeFunctionTranspose extends LimeFunction$p{constructor(t,e){super(t,{name:"transpose",mode:e}),this.operations.r=["er(arg{mat[1]})"],this.algorithms.set("r(arg{mat[1]})",t=>{var i=t.right.places[0];const r=[];for(let e=0;e<i.column;e++){r.push([]);for(let t=0;t<i.row;t++)r[e].push(this.lime.direct([i.places[t][e]]))}t.rus(this.lime.build("matrix")(r))})}}var transpose$1=LimeFunctionTranspose;const LimeFunction$o=_function;class LimeFunctionZeroMatrix extends LimeFunction$o{constructor(t,e){super(t,{name:"zeroMatrix",mode:e}),this.operations.r=["er(arg{int[1]})","er(arg{int[2]})"],this.algorithms.set("r(arg{int[1]})",i=>{const r=[];for(let e=0;e<i.right.value[0];e++){r.push([]);for(let t=0;t<i.right.value[0];t++)r[e].push(this.lime.direct([0]))}i.rus(this.lime.build("matrix")(r))}),this.algorithms.set("r(arg{int[2]})",i=>{const r=[];for(let e=0;e<i.right.value[0];e++){r.push([]);for(let t=0;t<i.right.value[1];t++)r[e].push(this.lime.direct([0]))}i.rus(this.lime.build("matrix")(r))})}}var zeroMatrix=LimeFunctionZeroMatrix;const LimeFunction$n=_function;class LimeFunctionAbsolute extends LimeFunction$n{constructor(t,e){super(t,{name:"absolute",mode:e}),this.operations.r=["er(arg{int[1]})","er(arg{rat[1]})"],this.algorithms.set("r(arg{int[1]})",t=>{t.rus(this.lime.direct([Math.abs(t.right.value[0])]))}),this.algorithms.set("r(arg{rat[1]})",t=>{t.rus(this.lime.direct([Math.abs(t.right.value[0].n),"/",Math.abs(t.right.value[0].d)]))})}}var absolute=LimeFunctionAbsolute;const LimeFunction$m=_function;class LimeFunctionCeiling extends LimeFunction$m{constructor(t,e){super(t,{name:"ceiling",mode:e}),this.operations.r=["er(arg{int[1]})","er(arg{rat[1]})"],this.algorithms.set("r(arg{int[1]})",t=>{t.rus(this.lime.direct([t.right.value[0]]))}),this.algorithms.set("r(arg{rat[1]})",t=>{t.rus(this.lime.direct([Math.ceil(t.right.value[0].n/t.right.value[0].d)]))})}}var ceiling=LimeFunctionCeiling;const LimeFunction$l=_function;class LimeFunctionFibonacci extends LimeFunction$l{constructor(t,e){super(t,{name:"fibonacci",mode:e}),this.operations.r=["er(arg{int[1]})"],this.algorithms.set("r(arg{int[1]})",t=>{var e=t.right.value[0];if(e<1)throw new Error("error:invalidArgumentLogic");this.lime.store.hasOwnProperty("fibonacci")||(this.lime.store.fibonacci=[1,1]);const i=[...this.lime.store.fibonacci];for(;i.length<e;)i.push(i[i.length-2]+i[i.length-1]);this.lime.store.fibonacci=[...i],t.rus(this.lime.direct([i[e-1]]))})}}var fibonacci$1=LimeFunctionFibonacci;const LimeFunction$k=_function;class LimeFunctionFloor extends LimeFunction$k{constructor(t,e){super(t,{name:"floor",mode:e}),this.operations.r=["er(arg{int[1]})","er(arg{rat[1]})"],this.algorithms.set("r(arg{int[1]})",t=>{t.rus(this.lime.direct([t.right.value[0]]))}),this.algorithms.set("r(arg{rat[1]})",t=>{t.rus(this.lime.direct([Math.floor(t.right.value[0].n/t.right.value[0].d)]))})}}var floor$1=LimeFunctionFloor;const LimeFunction$j=_function;class LimeFunctionGreatestCommonDivisor extends LimeFunction$j{constructor(t,e){super(t,{name:"greatestCommonDivisor",mode:e}),this.operations.r=["er(arg{int[2]})"],this.algorithms.set("r(arg{int[2]})",t=>{let e=t.right.value[0],i=t.right.value[1];for(;0!==i;){var r=i;i=e%i,e=r}t.rus(this.lime.direct([e]))})}}var greatestCommonDivisor=LimeFunctionGreatestCommonDivisor;const LimeFunction$i=_function;class LimeFunctionLeastCommonMultiple extends LimeFunction$i{constructor(t,e){super(t,{name:"leastCommonMultiple",mode:e}),this.operations.r=["er(arg{int[2]})"],this.algorithms.set("r(arg{int[2]})",t=>{var e=t.right.value[0],i=t.right.value[1];t.rus(this.lime.direct([e,"*",i,"/","gcd","(",e,",",i,")"]))})}}var leastCommonMultiple=LimeFunctionLeastCommonMultiple;const LimeFunction$h=_function;class LimeFunctionPrime extends LimeFunction$h{constructor(t,e){super(t,{name:"prime",mode:e}),this.operations.r=["er(arg{int[1]})"],this.algorithms.set("r(arg{int[1]})",t=>{var e=t.right.value[0];if(e<1)throw new Error("error:invalidArgumentLogic");this.lime.store.hasOwnProperty("prime")||(this.lime.store.prime=[2]);const i=[...this.lime.store.prime];let r=i[i.length-1]+1;for(;i.length<e;)i.every(t=>r%t!=0)&&i.push(r),r++;this.lime.store.prime=[...i],t.rus(this.lime.direct([i[e-1]]))})}}var prime$1=LimeFunctionPrime;const LimeFunction$g=_function;class LimeFunctionReciprocal extends LimeFunction$g{constructor(t,e){super(t,{name:"reciprocal",mode:e}),this.operations.r=["er(arg{expr[1]})"],this.algorithms.set("r(arg{expr[1]})",t=>{t.rus(this.lime.direct([1,"/",t.right.places[0]]))})}}var reciprocal$1=LimeFunctionReciprocal;const LimeFunction$f=_function;class LimeFunctionRound extends LimeFunction$f{constructor(t,e){super(t,{name:"round",mode:e}),this.operations.r=["er(arg{int[1]})","er(arg{rat[1]})"],this.algorithms.set("r(arg{int[1]})",t=>{t.rus(this.lime.direct([t.right.value[0]]))}),this.algorithms.set("r(arg{rat[1]})",t=>{t.rus(this.lime.direct([Math.round(t.right.value[0].n/t.right.value[0].d)]))})}}var round$1=LimeFunctionRound;const LimeFunction$e=_function;class LimeFunctionSign extends LimeFunction$e{constructor(t,e){super(t,{name:"sign",mode:e}),this.operations.r=["er(arg{int[1]})","er(arg{rat[1]})"],this.algorithms.set("r(arg{int[1]})",t=>{t.rus(this.lime.direct([Math.sign(t.right.value[0])]))}),this.algorithms.set("r(arg{rat[1]})",t=>{t.rus(this.lime.direct([Math.sign(t.right.value[0].n/t.right.value[0].d)]))})}}var sign=LimeFunctionSign;const LimeFunction$d=_function;class LimeFunctionTruncation extends LimeFunction$d{constructor(t,e){super(t,{name:"truncation",mode:e}),this.operations.r=["er(arg{int[1]})","er(arg{rat[1]})"],this.algorithms.set("r(arg{int[1]})",t=>{t.rus(this.lime.direct([t.right.value[0]]))}),this.algorithms.set("r(arg{rat[1]})",t=>{t.rus(this.lime.direct([Math.trunc(t.right.value[0].n/t.right.value[0].d)]))})}}var truncation=LimeFunctionTruncation;const LimeFunction$c=_function;class LimeFunctionMaximum extends LimeFunction$c{constructor(t,e){super(t,{name:"maximum",mode:e}),this.operations.r=["er(arg{expr[@]})"],this.algorithms.set("r(arg{expr[@]})",e=>{if(0===e.right.length)throw new Error("error:invalidArgumentLength");let i=0;for(let t=1;t<e.right.length;t++)i=this.lime.direct([e.right.places[t],">",e.right.places[i]]).value?t:i;e.rus(this.lime.direct([e.right.places[i]]))})}}var maximum=LimeFunctionMaximum;const LimeFunction$b=_function;class LimeFunctionMean extends LimeFunction$b{constructor(t,e){super(t,{name:"mean",mode:e}),this.operations.r=["er(arg{expr[@]})"],this.algorithms.set("r(arg{expr[@]})",t=>{if(0===t.right.length)throw new Error("error:invalidArgumentLength");t.rus(this.lime.direct(["sum",t.right,"/",t.right.length]))})}}var mean$1=LimeFunctionMean;const LimeFunction$a=_function;class LimeFunctionMinimum extends LimeFunction$a{constructor(t,e){super(t,{name:"minimum",mode:e}),this.operations.r=["er(arg{expr[@]})"],this.algorithms.set("r(arg{expr[@]})",e=>{if(0===e.right.length)throw new Error("error:invalidArgumentLength");let i=0;for(let t=1;t<e.right.length;t++)i=this.lime.direct([e.right.places[t],"<",e.right.places[i]]).value?t:i;e.rus(this.lime.direct([e.right.places[i]]))})}}var minimum=LimeFunctionMinimum;const LimeFunction$9=_function;class LimeFunctionProduct extends LimeFunction$9{constructor(t,e){super(t,{name:"product",mode:e}),this.operations.r=["er(arg{expr[@]})"],this.algorithms.set("r(arg{expr[@]})",e=>{if(0===e.right.length)throw new Error("error:invalidArgumentLength");let i=e.right.places[0];for(let t=1;t<e.right.length;t++)i=this.lime.direct([i,"*",e.right.places[t]]);e.rus(this.lime.direct([i]))})}}var product=LimeFunctionProduct;const LimeFunction$8=_function;class LimeFunctionRandom extends LimeFunction$8{constructor(t,e){super(t,{name:"random",mode:e}),this.operations.r=["er(arg{})","er(arg{int[1]})","er(arg{int[2]})"],this.algorithms.set("r(arg{})",t=>{t.rus(this.lime.direct([Math.floor(1e15*Math.random()),"/",1e15]))}),this.algorithms.set("r(arg{int[1]})",t=>{t.rus(this.lime.direct(["rand","(",0,",",t.right.places[0],")"]))}),this.algorithms.set("r(arg{int[2]})",t=>{var[e,i]=t.right.places;if(this.lime.direct([e.value,">",i.value]).value)throw new Error("error:invalidArgumentLogic");t.rus(this.lime.direct([Math.floor(Math.random()*(i.value-e.value+1)+e.value)]))})}}var random=LimeFunctionRandom;const LimeFunction$7=_function;class LimeFunctionRange extends LimeFunction$7{constructor(t,e){super(t,{name:"range",mode:e}),this.operations.r=["er(arg{expr[@]})"],this.algorithms.set("r(arg{expr[@]})",t=>{if(0===t.right.length)throw new Error("error:invalidArgumentLength");t.rus(this.lime.direct(["max",t.right,"-","min",t.right]))})}}var range$1=LimeFunctionRange;const LimeFunction$6=_function;class LimeFunctionSum extends LimeFunction$6{constructor(t,e){super(t,{name:"sum",mode:e}),this.operations.r=["er(arg{expr[@]})"],this.algorithms.set("r(arg{expr[@]})",e=>{if(0===e.right.length)throw new Error("error:invalidArgumentLength");let i=e.right.places[0];for(let t=1;t<e.right.length;t++)i=this.lime.direct([i,"+",e.right.places[t]]);e.rus(this.lime.direct([i]))})}}var sum$1=LimeFunctionSum;const LimeFunction$5=_function;class LimeFunctionAssign extends LimeFunction$5{constructor(t,e){super(t,{name:"assign",mode:e}),this.operations.b=["tf(==)","tr(_+)","tr(_-)","cr(var->expr)","cr(arg{expr[1]}->expr)","eb(var,expr)"],this.algorithms.set("b(var,expr)",t=>{this.lime.variables.set(t.left.key,t.right),t.bs(t.left)})}}var assign=LimeFunctionAssign;const LimeFunction$4=_function;class LimeFunctionColumnSplit extends LimeFunction$4{constructor(t,e){super(t,{name:"columnSplit",mode:e})}}var columnSplit=LimeFunctionColumnSplit;const LimeFunction$3=_function;class LimeFunctionCommonBracket extends LimeFunction$3{constructor(t,e){super(t,{name:"commonBracket",mode:e}),this.operations.n=["en()"],this.algorithms.set("n()",t=>{var e=t["data"];const i=[[]],r=[this];let n=t.pos,s=0;for(;n+1<e.length&&0<r.length;)if(this.lime.identify("commonBracket","matrixBracket")(e[n+1])){if("n"===e[n+1].mode)r.push(e[n+1]);else{if(e[n+1].name!==r[r.length-1].name)throw new Error("error:unmatchedBrackets");if(r.pop(),0===r.length)break}i[s].push(e[++n])}else if(this.lime.identify("columnSplit")(e[n+1])&&1===r.length)i.push([]),s++,n++;else{if(this.lime.identify("rowSplit")(e[n+1])&&1===r.length)throw new Error("error:functionAgreement");i[s].push(e[++n])}if(0<r.length)throw new Error("error:unmatchedBrackets");const o=[];let a=2+s;for(let t=0;t<=s;t++)a+=i[t].length,o.push(0<i[t].length?this.lime.direct(i[t]):null);t.ns(a,this.lime.build("argument")(...o))})}}var commonBracket=LimeFunctionCommonBracket;const LimeFunction$2=_function;class LimeFunctionMatrixBracket extends LimeFunction$2{constructor(t,e){super(t,{name:"matrixBracket",mode:e}),this.operations.n=["en()"],this.algorithms.set("n()",t=>{var e=t["data"];const i=[[[]]],r=[this];let n=t.pos,s=0,o=0;for(;n+1<e.length&&0<r.length;)if(this.lime.identify("commonBracket","matrixBracket")(e[n+1])){if("n"===e[n+1].mode)r.push(e[n+1]);else{if(e[n+1].name!==r[r.length-1].name)throw new Error("error:unmatchedBrackets");if(r.pop(),0===r.length)break}i[s][o].push(e[++n])}else if(this.lime.identify("columnSplit")(e[n+1])&&1===r.length)i[s].push([]),o++,n++;else if(this.lime.identify("rowSplit")(e[n+1])&&1===r.length){if(0<s&&i[s].length!==i[0].length)throw new Error("error:invalidArgumentLogic");i.push([[]]),s++,o=0,n++}else i[s][o].push(e[++n]);if(0<r.length)throw new Error("error:unmatchedBrackets");const a=[];let l=++s*++o+1;for(let e=0;e<s;e++){a.push([]);for(let t=0;t<o;t++)l+=i[e][t].length,a[e].push(0<i[e][t].length?this.lime.direct(i[e][t]):null)}t.ns(l,this.lime.build("matrix")(a))})}}var matrixBracket=LimeFunctionMatrixBracket;const LimeFunction$1=_function;class LimeFunctionOmitted extends LimeFunction$1{constructor(t,e){super(t,{name:"omitted",mode:e}),this.operations.b=["eb(mat,arg{int[1]})","eb(expr,expr)"],this.algorithms.set("b(mat,arg{int[1]})",t=>{t.bs(t.lime.direct(["index","(",t.left,",",t.right,")"]))}),this.algorithms.set("b(expr,expr)",t=>{t.fs(t.lime.refer("*"))})}}var omitted=LimeFunctionOmitted;const LimeFunction=_function;class LimeFunctionRowSplit extends LimeFunction{constructor(t,e){super(t,{name:"rowSplit",mode:e})}}var rowSplit=LimeFunctionRowSplit;class LimeEquation{constructor(t,e){this.lime=t,this.input=e,this.solution=[]}get steps(){return this.solution.length}get runtime(){return this.solution[this.steps-1].timestamp-this.solution[0].timestamp}get result(){return this.solution[this.steps-1].data}record(t){this.lime.config.promptShowSteps&&console.log(t.data),this.solution.push(t)}}var equation=LimeEquation;const Types$2=helpers["Types"];class LimeStep{constructor(t,e,i){this.lime=t,this.data=Types$2.isArray(e)?e:[],this.pos=Types$2.isNumber(i)&&0<=i&&i<this.data.length?i:-1,this.timestamp=Date.now()}get left(){return this.data[this.pos-1]}get func(){return this.data[this.pos]}get right(){return this.data[this.pos+1]}ci(...e){return(...t)=>this.lime.identify(...e)(...t)}lpi(...t){return this.lime.identify(...t)(this.left)}fi(...t){return this.lime.identify(...t)(this.func)}rpi(...t){return this.lime.identify(...t)(this.right)}bpi(...t){return this.lime.identify(...t)(this.left,this.right)}lps(...t){this.data.splice(this.pos-1,1,...t)}fs(...t){this.data.splice(this.pos,1,...t)}rps(...t){this.data.splice(this.pos+1,1,...t)}lus(...t){this.data.splice(this.pos-1,2,...t)}rus(...t){this.data.splice(this.pos,2,...t)}bs(...t){this.data.splice(this.pos-1,3,...t)}ns(t,...e){this.data.splice(this.pos,t,...e)}}var step=LimeStep;const Types$1=helpers["Types"];class LimeToken{constructor(t,e,i){this.lime=t,this.type=["integer","whitespace","symbol","variable"].includes(e)?e:"symbol",this.value=Types$1.isString(i)?i:""}}var token=LimeToken;const Module$1=new Map;Module$1.set("about",about$1),Module$1.set("clear",clear$1),Module$1.set("config",config$1),Module$1.set("help",help$1),Module$1.set("list",list$1),Module$1.set("argument",argument),Module$1.set("boolean",boolean),Module$1.set("complex",complex),Module$1.set("integer",integer),Module$1.set("matrix",matrix$1),Module$1.set("rational",rational),Module$1.set("variable",variable),Module$1.set("add",add),Module$1.set("decimal",decimal),Module$1.set("divide",divide),Module$1.set("exponent",exponent),Module$1.set("modulo",modulo),Module$1.set("multiply",multiply),Module$1.set("negative",negative),Module$1.set("positive",positive),Module$1.set("scalarAdd",scalarAdd),Module$1.set("scalarDivide",scalarDivide),Module$1.set("scalarExponent",scalarExponent),Module$1.set("scalarModulo",scalarModulo),Module$1.set("scalarMultiply",scalarMultiply),Module$1.set("scalarSubtract",scalarSubtract),Module$1.set("subtract",subtract),Module$1.set("bitwiseAnd",bitwiseAnd),Module$1.set("bitwiseNot",bitwiseNot),Module$1.set("bitwiseOr",bitwiseOr),Module$1.set("shiftLeft",shiftLeft),Module$1.set("shiftRight",shiftRight),Module$1.set("equal",equal),Module$1.set("greater",greater),Module$1.set("greaterEqual",greaterEqual),Module$1.set("notEqual",notEqual),Module$1.set("smaller",smaller),Module$1.set("smallerEqual",smallerEqual),Module$1.set("conjugate",conjugate),Module$1.set("imaginary",imaginary),Module$1.set("real",real),Module$1.set("combination",combination),Module$1.set("factorial",factorial),Module$1.set("permutation",permutation),Module$1.set("logicalAnd",logicalAnd),Module$1.set("logicalNot",logicalNot),Module$1.set("logicalOr",logicalOr),Module$1.set("adjoint",adjoint),Module$1.set("cofactor",cofactor),Module$1.set("determinant",determinant),Module$1.set("identityMatrix",identityMatrix),Module$1.set("index",matrix),Module$1.set("inverse",inverse),Module$1.set("minor",minor$1),Module$1.set("oneMatrix",oneMatrix),Module$1.set("reducedRowEchelonForm",reducedRowEchelonForm),Module$1.set("trace",trace),Module$1.set("transpose",transpose$1),Module$1.set("zeroMatrix",zeroMatrix),Module$1.set("absolute",absolute),Module$1.set("ceiling",ceiling),Module$1.set("fibonacci",fibonacci$1),Module$1.set("floor",floor$1),Module$1.set("greatestCommonDivisor",greatestCommonDivisor),Module$1.set("leastCommonMultiple",leastCommonMultiple),Module$1.set("prime",prime$1),Module$1.set("reciprocal",reciprocal$1),Module$1.set("round",round$1),Module$1.set("sign",sign),Module$1.set("truncation",truncation),Module$1.set("maximum",maximum),Module$1.set("mean",mean$1),Module$1.set("minimum",minimum),Module$1.set("product",product),Module$1.set("random",random),Module$1.set("range",range$1),Module$1.set("sum",sum$1),Module$1.set("assign",assign),Module$1.set("columnSplit",columnSplit),Module$1.set("commonBracket",commonBracket),Module$1.set("matrixBracket",matrixBracket),Module$1.set("omitted",omitted),Module$1.set("rowSplit",rowSplit),Module$1.set("command",command),Module$1.set("equation",equation),Module$1.set("expression",expression),Module$1.set("function",_function),Module$1.set("step",step),Module$1.set("token",token);var module=Module$1,developmentMode=!1,promptShowRuntime=!1,promptShowSteps=!1,strictBoolean=!0,tabSize=2,testMode=!1,require$$2={developmentMode:developmentMode,promptShowRuntime:promptShowRuntime,promptShowSteps:promptShowSteps,strictBoolean:strictBoolean,tabSize:tabSize,testMode:testMode},github="Please create a GitHub issue about how you received this message, thank you. ",require$$3={github:github,"error:emptyArgumentInFinalize":"Empty argument in finalize function.","error:functionAgreement":"Function does not agree with parameter types.","error:invalidArgumentLength":"Invalid argument length.","error:invalidArgumentLogic":"Invalid argument logic.","error:invalidMatrixDimensions":"Invalid matrix dimensions.","error:invalidParametersInCommand":"Invalid parameters in command.","error:inputEmptyInDirect":"Direct input is empty.","error:inputEmptyInPrompt":"Prompt input is empty.","error:inputNotArrayInDirect":"Direct input is not an array.","error:inputNotStringInPrompt":"Prompt input is not a string.","error:invalidConfigProperty":"Invalid configuration property in config command","error:invalidListProperty":"Invalid list property in list command","error:invalidSymbol":"Invalid symbol in prompt input.","error:undefinedVariable":"Variable is undefined but used.","error:unmatchedBrackets":"Some brackets are unmatched.","error:zeroMatrixDeterminant":"Determinant of matrix is zero.","issue:invalidExpressionInConstruct":"Invalid expression in constructor.","issue:invalidFunctionOrder":"Invalid function order.","issue:invalidMessage":"Invalid message detected.","issue:invalidModuleInBuild":"Invalid module in build function.","issue:invalidModuleInIdentify":"Invalid module in identify function.","issue:invalidResultLengthInProcess":"Invalid result length in process function.","issue:invalidTokenInParse":"Invalid token in parse function.","warn:negativeFactorial":"Factorial function has negative integer input. Currenly gamma function has not been implemented.","warn:strictBoolean":"Strict boolean configuration is set to true. Boolean to expression conversion is not allowed.","warn:zeroExponentOfZero":"Zero raised to exponent of zero is undefined."},about=["about"],clear=["clear"],config=["config"],help=["help"],list=["list"],i=["complex",["integer",0],["integer",1]],abs=["absolute","r"],adj=["adjoint","r"],ceil=["ceiling","r"],cof=["cofactor","r"],conj=["conjugate","r"],det=["determinant","r"],fibonacci=["fibonacci","r"],floor=["floor","r"],gcd=["greatestCommonDivisor","r"],idmat=["identityMatrix","r"],im=["imaginary","r"],index=["index","r"],inv=["inverse","r"],lcm=["leastCommonMultiple","r"],max=["maximum","r"],mean=["mean","r"],min=["minimum","r"],minor=["minor","r"],ncr=["combination","r"],npr=["permutation","r"],onemat=["oneMatrix","r"],prime=["prime","r"],prod=["product","r"],rand=["random","r"],range=["range","r"],re=["real","r"],reciprocal=["reciprocal","r"],round=["round","r"],rref=["reducedRowEchelonForm","r"],sgn=["sign","r"],sum=["sum","r"],tr=["trace","r"],transpose=["transpose","r"],trunc=["truncation","r"],zeromat=["zeroMatrix","r"],require$$4={about:about,clear:clear,config:config,help:help,list:list,false:["boolean",!1],i:i,true:["boolean",!0],"()":["argument",null],abs:abs,adj:adj,ceil:ceil,cof:cof,conj:conj,det:det,fibonacci:fibonacci,floor:floor,gcd:gcd,idmat:idmat,im:im,index:index,inv:inv,lcm:lcm,max:max,mean:mean,min:min,minor:minor,ncr:ncr,npr:npr,onemat:onemat,prime:prime,prod:prod,rand:rand,range:range,re:re,reciprocal:reciprocal,round:round,rref:rref,sgn:sgn,sum:sum,tr:tr,transpose:transpose,trunc:trunc,zeromat:zeromat,"+":["add","b"],"=":["assign","b"],"&":["bitwiseAnd","b"],"~":["bitwiseNot","r"],"|":["bitwiseOr","b"],",":["columnSplit","x"],"(":["commonBracket","n"],")":["commonBracket","x"],".":["decimal","b"],"/":["divide","b"],"==":["equal","b"],"^":["exponent","b"],"!":["factorial","l"],">":["greater","b"],">=":["greaterEqual","b"],"&&":["logicalAnd","b"],"_!":["logicalNot","r"],"||":["logicalOr","b"],"[":["matrixBracket","n"],"]":["matrixBracket","x"],"%":["modulo","b"],"*":["multiply","b"],"_-":["negative","r"],"!=":["notEqual","b"],"_+":["positive","r"],";":["rowSplit","x"],".+":["scalarAdd","b"],"./":["scalarDivide","b"],".^":["scalarExponent","b"],".%":["scalarModulo","b"],".*":["scalarMultiply","b"],".-":["scalarSubtract","b"],"<<":["shiftLeft","b"],">>":["shiftRight","b"],"<":["smaller","b"],"<=":["smallerEqual","b"],"-":["subtract","b"]};const Types=helpers["Types"],Module=module,Config=require$$2,Message=require$$3,Refer=require$$4;class Lime{constructor(t){this.config={...Config,...t},this.module=Module,this.variables=new Map,this.memory=[],this.store={}}get answer(){return this.variables.get("ans").print()}prompt(t){try{return this.run(t)}catch(t){return this.message(t)}}evaluate(t){try{return this.run(t)}catch(t){return console.log(this.message(t)),""}}run(t){if(!Types.isString(t))throw new Error("error:inputNotStringInPrompt");if(0===t.length)throw new Error("error:inputEmptyInPrompt");this.variables.has("ans")||this.variables.set("ans",this.direct([0]));const e=this.build("equation")(t);return this.lex(e),this.identify("command")(e.result[0])?e.result[0].execute(t):(this.memory.push(e),this.config.promptShowRuntime&&console.log(`Equation runtime: ${e.runtime/1e3}s`),this.variables.set("ans",e.result[0]),this.answer)}direct(t){try{if(!Types.isArray(t))throw new Error("error:inputNotArrayInDirect");if(0===t.length)throw new Error("error:inputEmptyInDirect");const e=this.build("equation")(t);return e.record(this.build("step")(e.input.map(t=>!Types.isString(t)&&!Types.isNumber(t)||Types.isUndefined(this.refer(t))?t:this.refer(t)))),this.process(e),e.result[0]}catch(t){return this.config.testMode?this.message(t):void console.log(this.message(t))}}message(t){var e=new Error("issue:invalidMessage");if(!Message.hasOwnProperty(t.message)||!t.message.includes(":"))return console.log(t),this.message(e);var i=t.message.split(":");let r;switch(i[0]){case"error":r="!";break;case"warn":r="?";break;case"issue":r="i";break;default:return this.message(e)}return this.config.developmentMode&&"i"===r&&console.log(t),`[${r}] ${i[1]}\n${Message[t.message]} ${"i"===r?`\n${Message.github}`:""}`}lex(t){const i=t.input,r=[];for(let e=0;e<i.length;e++){const n=i[e];let t=n;if(n.match(/\s/))r.push(this.build("token")("whitespace"));else if(n.match(/\d/)){for(;e+1<i.length&&i[e+1].match(/\d/);)t+=i[++e];r.push(this.build("token")("integer",t))}else if(n.match(/\w/)){for(;e+1<i.length&&i[e+1].match(/\w/);)t+=i[++e];r.push(this.build("token")("variable",t))}else r.push(this.build("token")("symbol",t))}t.record(r),this.parse(t)}parse(t){var e=t.solution.shift();const i=[];for(let t=0;t<e.length;t++)switch(e[t].type){case"whitespace":break;case"integer":i.push(this.build("integer")(e[t].value));break;case"symbol":case"variable":if(Refer.hasOwnProperty(e[t].value))i.push(this.refer(e[t].value));else{if("variable"!==e[t].type)throw new Error("error:invalidSymbol");i.push(this.build("variable")(e[t].value))}break;default:throw new Error("issue:invalidTokenInParse")}t.record(this.build("step")(i)),this.identify("command")(t.result[0])||this.process(t)}process(i){for(;;){for(let t=0;t<i.result.length;t++)0<t&&this.identify("expression")(i.result[t-1],i.result[t])&&i.result.splice(t,0,this.build("omitted")("b"));let e=-1;for(let t=0;t<i.result.length;t++)this.identify("function")(i.result[t])&&(e=e<0||i.result[t].order>i.result[e].order?t:e);if(e<0)break;var t=this.build("step")(i.result,e);i.record(i.result[e].evaluate(t))}if(1!==i.result.length||this.identify("argument")(i.result[0])&&1!==i.result[0].length)throw new Error("issue:invalidResultLengthInProcess");i.record(this.build("step")([i.result[0].finalize()]))}identify(...i){if(i.every(t=>this.module.has(t)))return(...t)=>t.every(e=>i.some(t=>Types.isClass(this.module.get(t),e)));throw new Error("issue:invalidModuleInIdentify")}build(e){if(this.module.has(e))return(...t)=>new(this.module.get(e))(this,...t);throw new Error("issue:invalidModuleInBuild")}refer(t){return Types.isNumber(t)?this.build("integer")(t):Refer.hasOwnProperty(t)?this.build(Refer[t][0])(...Refer[t].slice(1).map(t=>Types.isArray(t)?this.build(t[0])(...t.slice(1)):t)):void 0}}var lime=t=>new Lime(t);export{lime as default};
