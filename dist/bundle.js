/*
Lime version 0.3.2
Mathematics computation engine
2021-2022 Lime Project Team, MIT license
https://github.com/onenylxus/lime
*/

!function(t,r){"object"==typeof exports&&"undefined"!=typeof module?module.exports=r():"function"==typeof define&&define.amd?define(r):(t="undefined"!=typeof globalThis?globalThis:t||self).Lime=r()}(this,function(){"use strict";var t={},o={},c={};Object.defineProperty(c,"__esModule",{value:!0}),(Je=Ge=Ge||{})[Je.open=0]="open",Je[Je.leftBounded=1]="leftBounded",Je[Je.rightBounded=2]="rightBounded",Je[Je.closed=3]="closed";c.default=class{constructor(t,r,e=3){this._lower=t,this._upper=r,this._type=e}range(){return this._upper-this._lower}lower(){return this._lower}middle(){return(this._lower+this._upper)/2}upper(){return this._upper}within(t){return(this._type%2?t>=this.lower():t>this.lower())&&(1<this._type?t<=this.upper():t<this.upper())}clamp(t){for(;this._type%2?t<this.lower():t<=this.lower();)t+=this.range();for(;1<this._type?t>this.upper():t>=this.upper();)t-=this.range();return t}};var h={};Object.defineProperty(h,"__esModule",{value:!0});h.default=class{static isUndefined(...t){return t.every(t=>void 0===t)}static isNull(...t){return t.every(t=>null===t)}static isTrue(...t){return t.every(t=>!0===t)}static isFalse(...t){return t.every(t=>!1===t)}static isBoolean(...t){return t.every(t=>"boolean"==typeof t)}static isNumber(...t){return t.every(t=>"number"==typeof t)}static isBigInt(...t){return t.every(t=>"bigint"==typeof t)}static isString(...t){return t.every(t=>"string"==typeof t)}static isFunction(...t){return t.every(t=>"function"==typeof t)}static isSymbol(...t){return t.every(t=>"symbol"==typeof t)}static isArray(...t){return t.every(t=>t instanceof Array)}static isObject(...t){return t.every(t=>t instanceof Object)}static isClass(r,...t){return t.every(t=>t instanceof r)}},function(t){Object.defineProperty(t,"__esModule",{value:!0}),t._Integer=void 0;const i=c,r=h;var e,s;(e=e=e||{})[e.pre=0]="pre",e[e.post=1]="post";class n{constructor(t,r,e=0){this._value=0,this._signed=t,this._size=r,this.set(e)}get(){return this._value}set(t){this._value=this.clamp(t)}inc(t){return this.set(this.get()+1),this.clamp(t?this.get()-1:this.get())}dec(t){return this.set(this.get()-1),this.clamp(t?this.get()+1:this.get())}clamp(t){var r=2**this._size/2,e=this._signed?-1:0;return new i.default(r*e,r*(2+e),1).clamp(Math.trunc(t))}static toNumber(t){return r.default.isNumber(t)?t:t.get()}static toInteger(t,{signed:r=!1,size:e=8}){return new n(r,e,n.toNumber(t))}static get Int8(){return s.Int8}static get Int16(){return s.Int16}static get Int32(){return s.Int32}static get Uint8(){return s.Uint8}static get Uint16(){return s.Uint16}static get Uint32(){return s.Uint32}}t.default=n,function(t){class r extends n{constructor(t){super(!0,8,t)}}t.Int8=r;class e extends n{constructor(t){super(!0,16,t)}}t.Int16=e;class i extends n{constructor(t){super(!0,32,t)}}t.Int32=i;class s extends n{constructor(t){super(!1,8,t)}}t.Uint8=s;class a extends n{constructor(t){super(!1,16,t)}}t.Uint16=a;class l extends n{constructor(t){super(!1,32,t)}}t.Uint32=l}(s=t._Integer||(t._Integer={}))}(o);var m={},u={};!function(t){Object.defineProperty(t,"__esModule",{value:!0}),t._Vector=void 0;const r=c;class s{constructor(t){this._values=t}get values(){return[...this._values]}add(r){const e=[],i=this.maxSize(r);for(let t=0;t<i;t++)e.push(this.expand(i).values[t]+r.expand(i).values[t]);return s.build(e)}subtract(t){return this.add(t.scale(-1))}scale(r){return s.build(this.values.map(t=>t*r))}dot(r){var e=this.maxSize(r);let i=0;for(let t=0;t<e;t++)i+=this.expand(e).values[t]*r.expand(e).values[t];return i}length(){return Math.sqrt(this.dot(this))}normalize(){return 0<this.length()?this.scale(1/this.length()):void 0}size(){return this.values.length}maxSize(t){return Math.max(this.size(),t.size())}splice(e){if(new r.default(0,this.size()-1).within(e))return s.build(this.values.filter((t,r)=>r!==e))}expand(t){let r=this.values;for(;r.length<t;)r.push(0);return s.build(r)}static build(t){switch(t.length){case 2:return new s.Vector2(t);case 3:return new s.Vector3(t);case 4:return new s.Vector4(t);default:return new s(t)}}static fill(t,r){return s.build(new Array(t).fill(r))}static get Vector2(){return e.Vector2}static get Vector3(){return e.Vector3}static get Vector4(){return e.Vector4}}var e;t.default=s,function(t){class r extends s{constructor([t,r]){super([t,r])}get x(){return this.values[0]}get y(){return this.values[1]}}t.Vector2=r;class e extends s{constructor([t,r,e]){super([t,r,e])}get x(){return this.values[0]}get y(){return this.values[1]}get z(){return this.values[2]}cross(t){return new e([this.y*t.z-this.z*t.y,this.z*t.x-this.x*t.z,this.x*t.y-this.y*t.x])}}t.Vector3=e;class i extends s{constructor([t,r,e,i]){super([t,r,e,i])}get x(){return this.values[0]}get y(){return this.values[1]}get z(){return this.values[2]}get w(){return this.values[3]}}t.Vector4=i}(e=t._Vector||(t._Vector={}))}(u),function(t){Object.defineProperty(t,"__esModule",{value:!0}),t._Matrix=void 0;const i=c,s=u;class h{constructor(r){if(r.some(t=>t.size()!==r[0].size()))throw new Error;this._vectors=r}get vectors(){return[...this._vectors]}add(r){const e=[],i=this.maxRow(r),s=this.maxColumn(r);for(let t=0;t<i;t++)e.push(this.expand(i,s).vectors[t].add(r.expand(i,s).vectors[t]));return h.build(e)}subtract(t){return this.add(t.scale(-1))}scale(r){return h.build(this.vectors.map(t=>t.scale(r)))}mulMat(r){const e=[];for(let t=0;t<r.column();t++)e.push(this.mulVec(r.transpose().vectors[t]));return h.build(e).transpose()}mulVec(r){const e=[],i=Math.max(this.column(),r.size());for(let t=0;t<this.row();t++)e.push(this.expand(this.row(),i).vectors[t].dot(r));return s.default.build(e)}transpose(){const t=[];for(let r=0;r<this.column();r++)t.push(s.default.build(this.vectors.map(t=>t.values[r])));return h.build(t)}det(){if(this.square()){if(1===this.row())return this.vectors[0].values[0];let r=0;for(let t=0;t<this.row();t++)r+=this.vectors[0].values[t]*(t%2?-1:1)*this.minor(0,t).det();return r}}inverse(){if(this.square()&&0!==this.det()){if(1===this.row())return this.scale(1/this.det()**2);const t=[],i=(t,r)=>this.minor(t,r).det()*((t+r)%2?-1:1);for(let e=0;e<this.row();e++)t.push(s.default.build(this.vectors[e].values.map((t,r)=>i(e,r))));return h.build(t).transpose().scale(1/this.det())}}row(){return this.vectors.length}column(){return this.vectors[0].size()}maxRow(t){return Math.max(this.row(),t.row())}maxColumn(t){return Math.max(this.column(),t.column())}square(){return this.row()===this.column()}minor(e,r){if(new i.default(0,this.row()-1).within(e)&&new i.default(0,this.column()-1).within(r))return h.build(this.vectors.filter((t,r)=>r!==e).map(t=>t.splice(r)))}expand(t,r){let e=this.vectors;for(;e.length<t;)e.push(s.default.fill(r,0));return h.build(e.map(t=>t.expand(r)))}static build(t){const r=Math.max(...t.map(t=>t.size())),e=t.map(t=>t.expand(r));switch(e.length){case 2:switch(r){case 2:return new h.Matrix22(e);case 3:return new h.Matrix23(e);case 4:return new h.Matrix24(e);default:return new h(e)}case 3:switch(r){case 2:return new h.Matrix32(e);case 3:return new h.Matrix33(e);case 4:return new h.Matrix34(e);default:return new h(e)}case 4:switch(r){case 2:return new h.Matrix42(e);case 3:return new h.Matrix43(e);case 4:return new h.Matrix44(e);default:return new h(e)}default:return new h(e)}}static fill(t,r,e){return h.build(new Array(t).fill(s.default.fill(r,e)))}static get Matrix22(){return r.Matrix22}static get Matrix23(){return r.Matrix23}static get Matrix24(){return r.Matrix24}static get Matrix32(){return r.Matrix32}static get Matrix33(){return r.Matrix33}static get Matrix34(){return r.Matrix34}static get Matrix42(){return r.Matrix42}static get Matrix43(){return r.Matrix43}static get Matrix44(){return r.Matrix44}}var r;t.default=h,function(t){class r extends h{constructor([t,r]){if(2!==t.size()||2!==r.size())throw new Error;super([t,r])}get p(){return this.vectors[0]}get q(){return this.vectors[1]}}t.Matrix22=r;class e extends h{constructor([t,r]){if(super([t,r]),3!==t.size()||3!==r.size())throw new Error}get p(){return this.vectors[0]}get q(){return this.vectors[1]}}t.Matrix23=e;class i extends h{constructor([t,r]){if(super([t,r]),4!==t.size()||4!==r.size())throw new Error}get p(){return this.vectors[0]}get q(){return this.vectors[1]}}t.Matrix24=i;class s extends h{constructor([t,r,e]){if(super([t,r,e]),2!==t.size()||2!==r.size()||2!==e.size())throw new Error}get p(){return this.vectors[0]}get q(){return this.vectors[1]}get r(){return this.vectors[2]}}t.Matrix32=s;class a extends h{constructor([t,r,e]){if(super([t,r,e]),3!==t.size()||3!==r.size()||3!==e.size())throw new Error}get p(){return this.vectors[0]}get q(){return this.vectors[1]}get r(){return this.vectors[2]}}t.Matrix33=a;class l extends h{constructor([t,r,e]){if(super([t,r,e]),4!==t.size()||4!==r.size()||4!==e.size())throw new Error}get p(){return this.vectors[0]}get q(){return this.vectors[1]}get r(){return this.vectors[2]}}t.Matrix34=l;class n extends h{constructor([t,r,e,i]){if(super([t,r,e,i]),2!==t.size()||2!==r.size()||2!==e.size()||2!==i.size())throw new Error}get p(){return this.vectors[0]}get q(){return this.vectors[1]}get r(){return this.vectors[2]}get s(){return this.vectors[3]}}t.Matrix42=n;class o extends h{constructor([t,r,e,i]){if(super([t,r,e,i]),3!==t.size()||3!==r.size()||3!==e.size()||3!==i.size())throw new Error}get p(){return this.vectors[0]}get q(){return this.vectors[1]}get r(){return this.vectors[2]}get s(){return this.vectors[3]}}t.Matrix43=o;class c extends h{constructor([t,r,e,i]){if(super([t,r,e,i]),4!==t.size()||4!==r.size()||4!==e.size()||4!==i.size())throw new Error}get p(){return this.vectors[0]}get q(){return this.vectors[1]}get r(){return this.vectors[2]}get s(){return this.vectors[3]}}t.Matrix44=c}(r=t._Matrix||(t._Matrix={}))}(m);var p={};Object.defineProperty(p,"__esModule",{value:!0});p.default=class{constructor(t=0){this._capacity=0<t?t:1/0,this._head=0,this._tail=0,this._store={}}clear(){for(;!this.empty();)this.dequeue()}enqueue(t){this.size()<this._capacity&&(this._store[this._tail++]=t)}dequeue(){var t=this.top();return this.empty()||delete this._store[this._head++],t}top(){return this.empty()?void 0:this._store[this._head]}size(){return this._tail-this._head}empty(){return 0===this.size()}};var g={};Object.defineProperty(g,"__esModule",{value:!0});g.default=class{constructor(t=0){this._capacity=0<t?t:1/0,this._size=0,this._store={}}clear(){for(;!this.empty();)this.pop()}push(t){this.size()<this._capacity&&(this._store[this._size++]=t)}pop(){var t=this.top();return this.empty()||delete this._store[--this._size],t}top(){return this.empty()?void 0:this._store[this._size-1]}size(){return this._size}empty(){return 0===this.size()}},function(t){Object.defineProperty(t,"__esModule",{value:!0}),t.Vector=t.Types=t.Stack=t.Queue=t.Matrix=t.Interval=t.Integer=void 0;var r=o;Object.defineProperty(t,"Integer",{enumerable:!0,get:function(){return r.default}});var e=c;Object.defineProperty(t,"Interval",{enumerable:!0,get:function(){return e.default}});var i=m;Object.defineProperty(t,"Matrix",{enumerable:!0,get:function(){return i.default}});var s=p;Object.defineProperty(t,"Queue",{enumerable:!0,get:function(){return s.default}});var a=g;Object.defineProperty(t,"Stack",{enumerable:!0,get:function(){return a.default}});var l=h;Object.defineProperty(t,"Types",{enumerable:!0,get:function(){return l.default}});var n=u;Object.defineProperty(t,"Vector",{enumerable:!0,get:function(){return n.default}})}(t);const r={name:"@onenylxus/lime",version:"0.3.2",description:"Mathematics computation engine",author:"Lime Project Team",license:"MIT",keywords:["javascript","mathematics"],files:["dist/*","docs/*","LICENSE.md","README.md","yarn.lock"],main:"dist/bundle.js",module:"dist/bundle-cjs.js",browser:"dist/bundle-esm.js",sideEffects:!1,dependencies:{"@onenylxus/helpers":"^1.2.2"},devDependencies:{"@rollup/plugin-commonjs":"^20.0.0","@rollup/plugin-json":"^4.1.0","@rollup/plugin-node-resolve":"^13.0.0",codecov:"^3.8.2",eslint:"^7.25.0","eslint-config-airbnb-base":"^14.2.1","eslint-plugin-import":"^2.24.2",husky:"^7.0.2",jest:"^27.1.0","lint-staged":"^11.1.2","prettier-eslint":"^13.0.0","prettier-eslint-cli":"^5.0.1",rimraf:"^3.0.2",rollup:"^2.56.3","rollup-plugin-node-polyfills":"^0.2.1","rollup-plugin-uglify":"^6.0.4"},scripts:{lint:"prettier-eslint '**/*.js'",clean:"rimraf dist/*.js",debug:"node examples/prompt.js -q",prebuild:"yarn lint && yarn clean",build:"rollup -c",watch:"jest --config jest.config.json --watch",pretest:"yarn build",test:"jest --config jest.config.json --verbose"},husky:{hooks:{"pre-commit":"yarn test"}},repository:{type:"git",url:"git+https://github.com/onenylxus/lime.git"},bugs:{url:"https://github.com/onenylxus/lime/issues"},homepage:"https://github.com/onenylxus/lime#readme"};var e=class{constructor(t,{...r}){this.lime=t,this.name=r.hasOwnProperty("name")?r.name:this.constructor.name.slice(11),this.description=r.hasOwnProperty("description")?r.description:"",this.operations=new Map}execute(t){var r=t.split(/\s/).slice(1),t=r.length;if(!this.operations.has(t))throw new Error("error:invalidParametersInCommand");return this.operations.get(t)(...r)}};const i=function(){return["Lime version "+r.version,r.description,`2021-2022 ${r.author}, ${r.license} license`,r.homepage.slice(0,-7)].join("\n")};class s extends e{constructor(t){super(t,{name:"about",description:"show information about the engine"}),this.operations.set(0,()=>i())}}class a extends e{constructor(t){super(t,{name:"clear",description:"clear variables and memory"}),this.operations.set(0,()=>(this.lime.variables=new Map,this.lime.memory=[],this.lime.store={},"Cleared"))}}class l extends e{constructor(t){super(t,{name:"config",description:"view and modify engine configurations"}),this.operations.set(1,t=>{if(!this.lime.config.hasOwnProperty(t))throw new Error("error:invalidConfigProperty");return t+": "+this.lime.config[t]}),this.operations.set(2,(t,r)=>{if(!this.lime.config.hasOwnProperty(t))throw new Error("error:invalidConfigProperty");var e=this.lime.config[t];return this.lime.config[t]=this.lime.direct([r.match(/^[-+]?\d+$/)?+r:r]).value,t+`: ${e} > `+this.lime.config[t]})}}const n=e;class d extends n{constructor(t){super(t,{name:"help",description:"list all available commands"}),this.operations.set(0,()=>{const e=["Below is a list of available commands:"];return this.lime.module.forEach(t=>{try{var r=new t(this.lime);r instanceof n&&e.push(r.name+": "+r.description)}catch(t){}}),e.join("\n")})}}const f=t["Types"];class b extends e{constructor(t){super(t,{name:"list",description:"list specified engine property"}),this.operations.set(1,t=>{if(!this.lime.hasOwnProperty(t)||f.isFunction(this.lime[t]))throw new Error("error:invalidListProperty");t=this.lime[t];return f.isClass(Map,t)?Object.fromEntries(t):t})}}const v=t["Types"];var x=class{constructor(t,{...r}){this.lime=t,this.name=r.hasOwnProperty("name")?r.name:this.constructor.name.slice(12),this.isSimple=!r.hasOwnProperty("isSimple")||!v.isBoolean(r.isSimple)||r.isSimple}};const w=t["Types"];class y extends x{constructor(t,...r){if(super(t,{name:"argument",isSimple:!1}),!this.lime.identify("expression")(...r)&&!w.isNull(r[0]))throw new Error("issue:invalidExpressionInConstruct");this.places=r}get value(){return this.places.map(t=>t.value)}get length(){return this.isEmpty?0:this.places.length}get isEmpty(){return w.isNull(this.places[0])}simplify(){return this.places.map(t=>t.simplify())}finalize(){return 1===this.length?this.places[0].finalize():this.places.map(t=>t.finalize())}}var _=y;class P extends x{constructor(t,r){super(t,{name:"boolean",isSimple:!0}),this.raw=r}get value(){return!!this.raw}toInteger(){if(this.lime.config.strictBoolean)throw new Error("warn:strictBoolean");return this.lime.direct([+this.value])}simplify(){return this.lime.build("boolean")(this.value)}finalize(){return this.simplify()}print(){return this.value?"true":"false"}}var M=P;class E extends x{constructor(t,r,e){if(super(t,{name:"complex",isSimple:!0}),!this.lime.identify("integer","rational")(r,e))throw new Error("issue:invalidExpressionInConstruct");this.rPlace=r,this.iPlace=e}get value(){return{r:this.rPlace.value,i:this.iPlace.value}}toBoolean(){return this.lime.build("boolean")(this.value.r||this.value.i)}simplify(){return this.lime.direct([this.iPlace,"==",0]).value?this.rPlace.simplify():this.lime.build("complex")(this.rPlace.simplify(),this.iPlace.simplify())}finalize(){return this.simplify()}print(){var t=this.lime.direct(["sgn","(",this.iPlace,")"]).value;return`${0===this.value.r?"":this.rPlace.print()+(0<t?"+":"")}${1===this.value.i?"":-1===this.value.i?"-":this.iPlace.print()}i`}}var z=E;const I=t["Types"];class k extends x{constructor(t,r){if(super(t,{name:"integer",isSimple:!0}),!I.isNumber(+r))throw new Error("issue:invalidExpressionInConstruct");this.string=""+r}get value(){return Math.trunc(+this.string)}toBoolean(){return this.lime.build("boolean")(this.value)}toComplex(){return this.lime.build("complex")(this,this.lime.build("integer")(0))}toRational(){return this.lime.build("rational")(this,this.lime.build("integer")(1))}simplify(){return this.lime.build("integer")(this.value)}finalize(){return this.simplify()}print(){return""+this.value}}var S=k;class j extends x{constructor(t,r){if(super(t,{name:"matrix",isSimple:!1}),!this.lime.identify("expression")(...r.flat()))throw new Error("issue:invalidExpressionInConstruct");if(0<r.length&&r.some(t=>t.length!==r[0].length))throw new Error("error:invalidMatrixDimensions");this.places=r}get value(){return this.places.map(t=>t.map(t=>t.value))}get row(){return this.places.length}get column(){return 0===this.row?0:this.places[0].length}get size(){return this.row*this.column}get isEmpty(){return 0===this.size}simplify(){return this.places=this.places.map(t=>t.map(t=>t.simplify())),this}finalize(){return this.places=this.places.map(t=>t.map(t=>t.finalize())),this}print(){let e="";if(this.lime.config.testMode){e+="[";for(let r=0;r<this.row;r++){e+=0===r?"":";";for(let t=0;t<this.column;t++)e+=(0===t?"":",")+this.places[r][t].print()}e+="]"}else{var i=this.places.map(t=>t.map(t=>t.print().length));const s=[];for(let e=0;e<this.column;e++){let r=0;for(let t=0;t<this.row;t++)r=Math.max(i[t][e],r);s.push(r)}for(let r=0;r<this.row;r++){for(let t=0;t<this.column;t++)e+=new Array(s[t]-i[r][t]+this.lime.config.tabSize+1).join(" ")+this.places[r][t].print();e+=r<this.row-1?"\n":""}}return e}}var B=j;class O extends x{constructor(t,r,e){if(super(t,{name:"rational",isSimple:!0}),!this.lime.identify("integer")(r,e))throw new Error("issue:invalidExpressionInConstruct");this.nPlace=r,this.dPlace=e}get value(){return{n:this.nPlace.value,d:this.dPlace.value}}toBoolean(){return this.lime.build("boolean")(this.value.n/this.value.d)}toComplex(){return this.lime.build("complex")(this,this.lime.build("integer")(0))}simplify(){var t=this.lime.direct(["gcd","(",this.nPlace,",",this.dPlace,")"]);return this.nPlace=this.lime.direct([this.nPlace,"/",t]),this.dPlace=this.lime.direct([this.dPlace,"/",t]),this.value.d<0&&(this.nPlace=this.lime.direct(["-",this.nPlace]),this.dPlace=this.lime.direct(["-",this.dPlace])),1===this.value.d?this.nPlace.simplify():this.lime.build("rational")(this.nPlace.simplify(),this.dPlace.simplify())}finalize(){return this.simplify()}print(){if(0<=this.lime.config.decimalPlaces){var t=10**this.lime.config.decimalPlaces;return""+Math.round(this.value.n*t/this.value.d)/t}return this.nPlace.print()+"/"+this.dPlace.print()}}var q=O;class C extends x{constructor(t,...i){if(super(t,{name:"set",isSimple:!1}),!this.lime.identify("expression")(...i))throw new Error("issue:invalidExpressionInConstruct");this.places=[];for(let e=0;e<i.length;e++)this.places.some((t,r)=>e!==r&&this.lime.direct([t,"==",i[e]]).value)||this.places.push(i[e])}get value(){return this.places.map(t=>t.value)}get length(){return this.places.length}get isEmpty(){return 0===this.length}simplify(){return this.places=this.places.map(t=>t.simplify()),this}finalize(){return this.places=this.places.map(t=>t.finalize()),this}print(){var r=this.lime.config.testMode?"":" ";let e="{";for(let t=0;t<this.length;t++)e+=r+this.places[t].print()+(t<this.length-1?",":"");return e+r+"}"}}var A=C;class D extends x{constructor(t,r){super(t,{name:"string",isSimple:!0}),this.value=r}simplify(){return this}finalize(){return this.simplify()}print(){return`"${this.value}"`}}var N=D;class $ extends x{constructor(t,r){super(t,{name:"variable",isSimple:!0}),this.key=r}get value(){if(!this.lime.variables.has(this.key))throw new Error("error:undefinedVariable");return this.lime.variables.get(this.key)}simplify(){return this.value.simplify()}finalize(){return this.simplify()}}var L=$;const V=t["Types"],T={cond:{"b(bool,bool)":t=>t.bpi("boolean"),"b(comp,comp)":t=>t.bpi("complex"),"b(comp,{int|rat})":t=>t.lpi("complex")&&t.rpi("integer","rational"),"b(expr,expr)":t=>t.bpi("expression"),"b(expr,str)":t=>t.lpi("expression")&&t.rpi("string"),"b(int,int)":t=>t.bpi("integer"),"b(int,mat)":t=>t.lpi("integer")&&t.rpi("matrix"),"b(int,rat)":t=>t.lpi("integer")&&t.rpi("rational"),"b(mat,arg{int[1]})":t=>t.lpi("matrix")&&t.rpi("argument")&&1===t.right.length&&t.ci("integer")(...t.right.places),"b(mat,int)":t=>t.lpi("matrix")&&t.rpi("integer"),"b(mat,mat)":t=>t.bpi("matrix"),"b(mat,{comp|int|rat})":t=>t.lpi("matrix")&&t.rpi("complex","integer","rational"),"b(rat,int)":t=>t.lpi("rational")&&t.rpi("integer"),"b(rat,rat)":t=>t.bpi("rational"),"b(str,str)":t=>t.bpi("string"),"b(var,expr)":t=>t.lpi("variable")&&t.rpi("expression"),"b({comp|int|rat},mat)":t=>t.lpi("complex","integer","rational")&&t.rpi("matrix"),"b({int|rat},comp)":t=>t.lpi("integer","rational")&&t.rpi("complex"),"b({int|rat},mat)":t=>t.lpi("integer","rational")&&t.rpi("matrix"),"l(arg{expr[1]})":t=>t.lpi("argument")&&1===t.left.length&&t.ci("expression")(...t.left.places),"l(bool)":t=>t.lpi("boolean"),"l(int)":t=>t.lpi("integer"),"l(var)":t=>t.lpi("variable"),"l({comp|int|rat})":t=>t.lpi("complex","integer","rational"),"n()":()=>!0,"r(arg{})":t=>t.rpi("argument")&&t.right.isEmpty,"r(arg{comp[1]})":t=>t.rpi("argument")&&1===t.right.length&&t.ci("complex")(...t.right.places),"r(arg{expr[1]})":t=>t.rpi("argument")&&1===t.right.length&&t.ci("expression")(...t.right.places),"r(arg{expr[@]})":t=>t.rpi("argument")&&t.ci("expression")(...t.right.places),"r(arg{int[1]})":t=>t.rpi("argument")&&1===t.right.length&&t.ci("integer")(...t.right.places),"r(arg{int[2]})":t=>t.rpi("argument")&&2===t.right.length&&t.ci("integer")(...t.right.places),"r(arg{rat[1]})":t=>t.rpi("argument")&&1===t.right.length&&t.ci("rational")(...t.right.places),"r(arg{set[2]})":t=>t.rpi("argument")&&2===t.right.length&&t.ci("set")(...t.right.places),"r(arg{mat[1]})":t=>t.rpi("argument")&&1===t.right.length&&t.ci("matrix")(...t.right.places),"r(arg{mat[1],int[1]})":t=>t.rpi("argument")&&2===t.right.length&&t.ci("matrix")(t.right.places[0])&&t.ci("integer")(t.right.places[1]),"r(arg{mat[1],int[2]})":t=>t.rpi("argument")&&3===t.right.length&&t.ci("matrix")(t.right.places[0])&&t.ci("integer")(t.right.places[1],t.right.places[2]),"r(arg{str[1]})":t=>t.rpi("argument")&&1===t.right.length&&t.ci("string")(...t.right.places),"r(arg{str[@]})":t=>t.rpi("argument")&&t.ci("string")(...t.right.places),"r(arg{{int|rat}[$]})":r=>r.rpi("argument")&&r.right.places.some(t=>r.ci("integer","rational")(t)),"r(bool)":t=>t.rpi("boolean"),"r(int)":t=>t.rpi("integer"),"r(mat)":t=>t.rpi("matrix"),"r(rat)":t=>t.rpi("rational"),"r(var)":t=>t.rpi("variable"),"r({comp|int|rat})":t=>t.rpi("complex","integer","rational"),"r(+)":t=>t.rpi("add"),"r(=)":t=>t.rpi("assign"),"r(&)":t=>t.rpi("bitwiseAnd"),"r(|)":t=>t.rpi("bitwiseOr"),"r(/)":t=>t.rpi("divide"),"r(^)":t=>t.rpi("exponent"),"r(!)":t=>t.rpi("factorial"),"r(>)":t=>t.rpi("greater"),"r(%)":t=>t.rpi("modulo"),"r(*)":t=>t.rpi("multiply"),"r(_-)":t=>t.rpi("negative"),"r(_+)":t=>t.rpi("positive"),"r(<)":t=>t.rpi("smaller"),"r(-)":t=>t.rpi("subtract"),"z()":t=>0===t.pos},act:{"f(_.)":t=>{t.fs(t.lime.refer("_."))},"f(==)":t=>{t.rus(t.lime.refer("=="))},"f(!==)":t=>{t.rus(t.lime.refer("!"),t.lime.refer("=="))},"f(>=)":t=>{t.rus(t.lime.refer(">="))},"f(&&)":t=>{t.rus(t.lime.refer("&&"))},"f(_!)":t=>{t.fs(t.lime.refer("_!"))},"f(||)":t=>{t.rus(t.lime.refer("||"))},"f(_-)":t=>{t.fs(t.lime.refer("_-"))},"f(!=)":t=>{t.rus(t.lime.refer("!="))},"f(_+)":t=>{t.fs(t.lime.refer("_+"))},"f(.+)":t=>{t.rus(t.lime.refer(".+"))},"f(./)":t=>{t.rus(t.lime.refer("./"))},"f(.^)":t=>{t.rus(t.lime.refer(".^"))},"f(.%)":t=>{t.rus(t.lime.refer(".%"))},"f(.*)":t=>{t.rus(t.lime.refer(".*"))},"f(.-)":t=>{t.rus(t.lime.refer(".-"))},"f(<<)":t=>{t.rus(t.lime.refer("<<"))},"f(>>)":t=>{t.rus(t.lime.refer(">>"))},"f(<=)":t=>{t.rus(t.lime.refer("<="))},"l(arg{expr[1]}->expr)":t=>{t.lps(t.left.finalize())},"l(expr->int)":t=>{t.lps(t.left.toInteger())},"l(expr->rat)":t=>{t.lps(t.left.toRational())},"l(var->expr)":t=>{t.lps(t.left.value)},"l({comp|int|rat}->bool)":t=>{t.lps(t.left.toBoolean())},"l({int|rat}->comp)":t=>{t.lps(t.left.toComplex())},"r(arg{expr[1]}->expr)":t=>{t.rps(t.right.finalize())},"r(arg{{int|rat}[$]}->arg{comp[$]})":r=>{const t=r.right;t.places=t.places.map(t=>r.ci("integer","rational")(t)?t.toComplex():t),r.rps(t)},"r(expr->int)":t=>{t.rps(t.right.toInteger())},"r(expr->rat)":t=>{t.rps(t.right.toRational())},"r(var->expr)":t=>{t.rps(t.right.value)},"r({comp|int|rat}->bool)":t=>{t.rps(t.right.toBoolean())},"r({int|rat}->comp)":t=>{t.rps(t.right.toComplex())},"r(_!)":t=>{t.rps(t.lime.refer("_!"))},"r(_-)":t=>{t.rps(t.lime.refer("_-"))},"r(_+)":t=>{t.rps(t.lime.refer("_+"))}},pair:{"cb(comp,{int|rat}->comp)":["b(comp,{int|rat})","r({int|rat}->comp)"],"cb(int->rat,rat)":["b(int,rat)","l(expr->rat)"],"cb(rat,int->rat)":["b(rat,int)","r(expr->rat)"],"cb({int|rat}->comp,comp)":["b({int|rat},comp)","l({int|rat}->comp)"],"cl(arg{expr[1]}->expr)":["l(arg{expr[1]})","l(arg{expr[1]}->expr)"],"cl(bool->int)":["l(bool)","l(expr->int)"],"cl(var->expr)":["l(var)","l(var->expr)"],"cl({comp|int|rat}->bool)":["l({comp|int|rat})","l({comp|int|rat}->bool)"],"cr(arg{expr[1]}->expr)":["r(arg{expr[1]})","r(arg{expr[1]}->expr)"],"cr(arg{{int|rat}[$]}->arg{comp[$]})":["r(arg{{int|rat}[$]})","r(arg{{int|rat}[$]}->arg{comp[$]})"],"cr(bool->int)":["r(bool)","r(expr->int)"],"cr(var->expr)":["r(var)","r(var->expr)"],"cr({comp|int|rat}->bool)":["r({comp|int|rat})","r({comp|int|rat}->bool)"],"tf(_.)":["b(int,int)","f(_.)"],"tf(==)":["r(=)","f(==)"],"tf(!==)":["r(=)","f(!==)"],"tf(>=)":["r(=)","f(>=)"],"tf(&&)":["r(&)","f(&&)"],"tf(||)":["r(|)","f(||)"],"tf(!=)":["r(=)","f(!=)"],"tf(.+)":["r(+)","f(.+)"],"tf(./)":["r(/)","f(./)"],"tf(.^)":["r(^)","f(.^)"],"tf(.%)":["r(%)","f(.%)"],"tf(.*)":["r(*)","f(.*)"],"tf(.-)":["r(-)","f(.-)"],"tf(<<)":["r(<)","f(<<)"],"tf(>>)":["r(>)","f(>>)"],"tf(<=)":["r(=)","f(<=)"],"tr(_!)":["r(!)","r(_!)"],"tr(_+)":["r(+)","r(_+)"],"tr(_-)":["r(-)","r(_-)"],"tz(_!)":["z()","f(_!)"],"tz(_+)":["z()","f(_+)"],"tz(_-)":["z()","f(_-)"]}},F=[["columnSplit","rowSplit"],["assign","equal","greater","greaterEqual","notEqual","smaller","smallerEqual"],["add","bitwiseAnd","bitwiseNot","bitwiseOr","logicalAnd","logicalNot","logicalOr","modulo","scalarAdd","scalarModulo","scalarSubtract","shiftLeft","shiftRight","subtract"],["divide","multiply","scalarDivide","scalarMultiply"],["exponent","scalarExponent"],["decimal","negative","positive"],["absolute","adjoint","ceiling","cofactor","combination","concatenate","conjugate","determinant","factor","factorial","fibonacci","floor","greatestCommonDivisor","hilbertMatrix","identityMatrix","imaginary","index","intersection","inverse","leastCommonMultiple","length","magicMatrix","maximum","mean","memory","minimum","minor","oneMatrix","permutation","prime","product","property","random","range","real","reciprocal","reducedRowEchelonForm","round","sign","sum","trace","transpose","truncation","type","union","zeroMatrix"],["commonBracket","matrixBracket","omitted","setBracket"]];var R=class{constructor(t,{...r}){this.lime=t,this.mode=r.hasOwnProperty("mode")&&["l","r","b","n"].includes(r.mode)?r.mode:"x",this.name=r.hasOwnProperty("name")?r.name:this.constructor.name.slice(12),this.operations={},this.algorithms=new Map}get order(){for(let t=0;t<F.length;t++)if(F[t].includes(this.name))return t;throw new Error("issue:invalidFunctionOrder")}evaluate(i){if("x"===this.mode)throw new Error("error:unmatchedBrackets");const s=this.operations[this.mode];for(let e=0;e<s.length;e++){let t,r;if(V.isString(s[e])&&(t="e"===s[e][0]?T.cond[s[e].substring(1)]:T.cond[T.pair[s[e]][0]],r="e"===s[e][0]?this.algorithms.get(s[e].substring(1)):T.act[T.pair[s[e]][1]]),t(i)&&(r(i),"c"!==s[e][0]))return i}throw new Error("error:functionAgreement")}};class U extends R{constructor(t,r){super(t,{name:"add",mode:r}),this.operations.b=["tz(_+)","tr(_!)","tr(_+)","tr(_-)","cl(var->expr)","cr(var->expr)","cl(arg{expr[1]}->expr)","cr(arg{expr[1]}->expr)","cl(bool->int)","cr(bool->int)","cb(int->rat,rat)","cb(rat,int->rat)","cb({int|rat}->comp,comp)","cb(comp,{int|rat}->comp)","eb(int,int)","eb(rat,rat)","eb(comp,comp)","eb(mat,mat)","eb(str,str)"],this.algorithms.set("b(int,int)",t=>{t.bs(this.lime.build("integer")(t.left.value+t.right.value))}),this.algorithms.set("b(rat,rat)",t=>{t.bs(this.lime.build("rational")(this.lime.direct([t.left.nPlace,"*",t.right.dPlace,"+",t.right.nPlace,"*",t.left.dPlace]),this.lime.direct([t.left.dPlace,"*",t.right.dPlace])))}),this.algorithms.set("b(comp,comp)",t=>{t.bs(this.lime.build("complex")(this.lime.direct([t.left.rPlace,"+",t.right.rPlace]),this.lime.direct([t.left.iPlace,"+",t.right.iPlace])))}),this.algorithms.set("b(mat,mat)",e=>{if(e.left.row!==e.right.row||e.left.column!==e.right.column)throw new Error("error:invalidMatrixDimensions");const i=[];for(let r=0;r<e.left.row;r++){i.push([]);for(let t=0;t<e.left.column;t++)i[r].push(this.lime.direct([e.left.places[r][t],"+",e.right.places[r][t]]))}e.bs(this.lime.build("matrix")(i))}),this.algorithms.set("b(str,str)",t=>{t.bs(this.lime.direct(["concat","(",t.left,",",t.right,")"]))})}}var W=U;class Z extends R{constructor(t,r){super(t,{name:"decimal",mode:r}),this.operations.b=["eb(int,int)"],this.algorithms.set("b(int,int)",t=>{var r;0<t.right.value?(r=this.lime.direct([10,"^",t.right.string.length]),t.bs(this.lime.direct(["(",t.left,"*",r,"+",t.right,")","/",r]))):t.bs(t.left)})}}var Q=Z;class G extends R{constructor(t,r){super(t,{name:"divide",mode:r}),this.operations.b=["tr(_!)","tr(_+)","tr(_-)","cl(var->expr)","cr(var->expr)","cl(arg{expr[1]}->expr)","cr(arg{expr[1]}->expr)","cl(bool->int)","cr(bool->int)","cb(int->rat,rat)","cb(rat,int->rat)","cb({int|rat}->comp,comp)","cb(comp,{int|rat}->comp)","eb(int,int)","eb(rat,rat)","eb(comp,comp)"],this.algorithms.set("b(int,int)",t=>{t.left.value%t.right.value==0?t.bs(this.lime.build("integer")(t.left.value/t.right.value)):t.bs(this.lime.build("rational")(t.left,t.right))}),this.algorithms.set("b(rat,rat)",t=>{t.bs(this.lime.build("rational")(this.lime.direct([t.left.nPlace,"*",t.right.dPlace]),this.lime.direct([t.left.dPlace,"*",t.right.nPlace])))}),this.algorithms.set("b(comp,comp)",t=>{t.bs(this.lime.build("complex")(this.lime.direct(["re","(",t.left,"*","conj","(",t.right,")",")","/","(",t.right,"*","conj","(",t.right,")",")"]),this.lime.direct(["im","(",t.left,"*","conj","(",t.right,")",")","/","(",t.right,"*","conj","(",t.right,")",")"])))})}}var H=G;class J extends R{constructor(t,r){super(t,{name:"exponent",mode:r}),this.operations.b=["tr(_!)","tr(_+)","tr(_-)","cl(var->expr)","cr(var->expr)","cl(arg{expr[1]}->expr)","cr(arg{expr[1]}->expr)","cl(bool->int)","cr(bool->int)","eb(int,int)","eb(rat,int)"],this.algorithms.set("b(int,int)",t=>{if(0<=t.right.value){if(0===t.left.value&&0===t.right.value)throw new Error("warn:zeroExponentOfZero");t.bs(this.lime.build("integer")(t.left.value**t.right.value))}else t.bs(this.lime.build("rational")(this.lime.direct([1]),this.lime.direct([t.left,"^","-",t.right])))}),this.algorithms.set("b(rat,int)",t=>{0<=t.right.value?t.bs(this.lime.build("rational")(this.lime.direct([t.left.nPlace,"^",t.right]),this.lime.direct([t.left.dPlace,"^",t.right]))):t.bs(this.lime.build("rational")(this.lime.direct([t.left.dPlace,"^","-",t.right]),this.lime.direct([t.left.nPlace,"^","-",t.right])))})}}var K=J;class X extends R{constructor(t,r){super(t,{name:"modulo",mode:r}),this.operations.b=["tr(_!)","tr(_+)","tr(_-)","cl(var->expr)","cr(var->expr)","cl(arg{expr[1]}->expr)","cr(arg{expr[1]}->expr)","cl(bool->int)","cr(bool->int)","eb(int,int)"],this.algorithms.set("b(int,int)",t=>{t.bs(this.lime.build("integer")(t.left.value%t.right.value))})}}var Y=X;class tt extends R{constructor(t,r){super(t,{name:"multiply",mode:r}),this.operations.b=["tr(_!)","tr(_+)","tr(_-)","cl(var->expr)","cr(var->expr)","cl(arg{expr[1]}->expr)","cr(arg{expr[1]}->expr)","cl(bool->int)","cr(bool->int)","cb(int->rat,rat)","cb(rat,int->rat)","cb({int|rat}->comp,comp)","cb(comp,{int|rat}->comp)","eb(int,int)","eb(rat,rat)","eb(comp,comp)","eb(mat,mat)"],this.algorithms.set("b(int,int)",t=>{t.bs(this.lime.build("integer")(t.left.value*t.right.value))}),this.algorithms.set("b(rat,rat)",t=>{t.bs(this.lime.build("rational")(this.lime.direct([t.left.nPlace,"*",t.right.nPlace]),this.lime.direct([t.left.dPlace,"*",t.right.dPlace])))}),this.algorithms.set("b(comp,comp)",t=>{t.bs(this.lime.build("complex")(this.lime.direct([t.left.rPlace,"*",t.right.rPlace,"-",t.left.iPlace,"*",t.right.iPlace]),this.lime.direct([t.left.rPlace,"*",t.right.iPlace,"+",t.left.iPlace,"*",t.right.rPlace])))}),this.algorithms.set("b(mat,mat)",s=>{if(s.left.column!==s.right.row)throw new Error("error:invalidMatrixDimensions");const t=[];for(let i=0;i<s.left.row;i++){t.push([]);for(let e=0;e<s.right.column;e++){let r=this.lime.direct([0]);for(let t=0;t<s.right.row;t++)r=this.lime.direct([r,"+",s.left.places[i][t],"*",s.right.places[t][e]]);t[i].push(r)}}s.bs(this.lime.build("matrix")(t))})}}var rt=tt;class et extends R{constructor(t,r){super(t,{name:"negative",mode:r}),this.operations.r=["tr(_!)","tr(_+)","tr(_-)","cr(var->expr)","cr(arg{expr[1]}->expr)","cr(bool->int)","er({comp|int|rat})","er(mat)","er(_+)","er(_-)"],this.algorithms.set("r({comp|int|rat})",t=>{t.rus(this.lime.direct([-1,"*",t.right]))}),this.algorithms.set("r(mat)",t=>{t.rus(this.lime.direct([-1,".*",t.right]))}),this.algorithms.set("r(_+)",t=>{t.rus(this.lime.refer("_-"))}),this.algorithms.set("r(_-)",t=>{t.rus(this.lime.refer("_+"))})}}var it=et;class st extends R{constructor(t,r){super(t,{name:"positive",mode:r}),this.operations.r=["tr(_!)","tr(_+)","tr(_-)","cr(var->expr)","cr(arg{expr[1]}->expr)","cr(bool->int)","er({comp|int|rat})","er(mat)","er(_+)","er(_-)"],this.algorithms.set("r({comp|int|rat})",t=>{t.rus(this.lime.direct([1,"*",t.right]))}),this.algorithms.set("r(mat)",t=>{t.rus(this.lime.direct([1,".*",t.right]))}),this.algorithms.set("r(_+)",t=>{t.rus(this.lime.refer("_+"))}),this.algorithms.set("r(_-)",t=>{t.rus(this.lime.refer("_-"))})}}var at=st;class lt extends R{constructor(t,r){super(t,{name:"scalarAdd",mode:r}),this.operations.b=["cl(arg{expr[1]}->expr)","cr(arg{expr[1]}->expr)","cl(bool->int)","cr(bool->int)","eb(mat,mat)","eb(mat,{comp|int|rat})","eb({comp|int|rat},mat)"],this.algorithms.set("b(mat,mat)",t=>{t.bs(this.lime.direct([t.left,"+",t.right]))}),this.algorithms.set("b(mat,{comp|int|rat})",e=>{const i=[];for(let r=0;r<e.left.row;r++){i.push([]);for(let t=0;t<e.left.column;t++)i[r].push(this.lime.direct([e.left.places[r][t],"+",e.right]))}e.bs(this.lime.build("matrix")(i))}),this.algorithms.set("b({comp|int|rat},mat)",e=>{const i=[];for(let r=0;r<e.right.row;r++){i.push([]);for(let t=0;t<e.right.column;t++)i[r].push(this.lime.direct([e.left,"+",e.right.places[r][t]]))}e.bs(this.lime.build("matrix")(i))})}}var nt=lt;class ot extends R{constructor(t,r){super(t,{name:"scalarDivide",mode:r}),this.operations.b=["cl(arg{expr[1]}->expr)","cr(arg{expr[1]}->expr)","cl(bool->int)","cr(bool->int)","eb(mat,mat)","eb(mat,{comp|int|rat})","eb({comp|int|rat},mat)"],this.algorithms.set("b(mat,mat)",e=>{if(e.left.row!==e.right.row||e.left.column!==e.right.column)throw new Error("error:invalidMatrixDimensions");const i=[];for(let r=0;r<e.left.row;r++){i.push([]);for(let t=0;t<e.left.column;t++)i[r].push(this.lime.direct([e.left.places[r][t],"/",e.right.places[r][t]]))}e.bs(this.lime.build("matrix")(i))}),this.algorithms.set("b(mat,{comp|int|rat})",e=>{const i=[];for(let r=0;r<e.left.row;r++){i.push([]);for(let t=0;t<e.left.column;t++)i[r].push(this.lime.direct([e.left.places[r][t],"/",e.right]))}e.bs(this.lime.build("matrix")(i))}),this.algorithms.set("b({comp|int|rat},mat)",e=>{const i=[];for(let r=0;r<e.right.row;r++){i.push([]);for(let t=0;t<e.right.column;t++)i[r].push(this.lime.direct([e.left,"/",e.right.places[r][t]]))}e.bs(this.lime.build("matrix")(i))})}}var ct=ot;class ht extends R{constructor(t,r){super(t,{name:"scalarExponent",mode:r}),this.operations.b=["cl(arg{expr[1]}->expr)","cr(arg{expr[1]}->expr)","cl(bool->int)","cr(bool->int)","eb(mat,int)","eb(mat,mat)","eb({int|rat},mat)"],this.algorithms.set("b(mat,int)",e=>{const i=[];for(let r=0;r<e.left.row;r++){i.push([]);for(let t=0;t<e.left.column;t++)i[r].push(this.lime.direct([e.left.places[r][t],"^",e.right]))}e.bs(this.lime.build("matrix")(i))}),this.algorithms.set("b(mat,mat)",e=>{if(e.left.row!==e.right.row||e.left.column!==e.right.column)throw new Error("error:invalidMatrixDimensions");const i=[];for(let r=0;r<e.left.row;r++){i.push([]);for(let t=0;t<e.left.column;t++)i[r].push(this.lime.direct([e.left.places[r][t],"^",e.right.places[r][t]]))}e.bs(this.lime.build("matrix")(i))}),this.algorithms.set("b({int|rat},mat)",e=>{const i=[];for(let r=0;r<e.right.row;r++){i.push([]);for(let t=0;t<e.right.column;t++)i[r].push(this.lime.direct([e.left,"^",e.right.places[r][t]]))}e.bs(this.lime.build("matrix")(i))})}}var mt=ht;class ut extends R{constructor(t,r){super(t,{name:"scalarModulo",mode:r}),this.operations.b=["cl(arg{expr[1]}->expr)","cr(arg{expr[1]}->expr)","cl(bool->int)","cr(bool->int)","eb(int,mat)","eb(mat,int)","eb(mat,mat)"],this.algorithms.set("b(int,mat)",e=>{const i=[];for(let r=0;r<e.right.row;r++){i.push([]);for(let t=0;t<e.right.column;t++)i[r].push(this.lime.direct([e.left,"%",e.right.places[r][t]]))}e.bs(this.lime.build("matrix")(i))}),this.algorithms.set("b(mat,int)",e=>{const i=[];for(let r=0;r<e.left.row;r++){i.push([]);for(let t=0;t<e.left.column;t++)i[r].push(this.lime.direct([e.left.places[r][t],"%",e.right]))}e.bs(this.lime.build("matrix")(i))}),this.algorithms.set("b(mat,mat)",e=>{if(e.left.row!==e.right.row||e.left.column!==e.right.column)throw new Error("error:invalidMatrixDimensions");const i=[];for(let r=0;r<e.left.row;r++){i.push([]);for(let t=0;t<e.left.column;t++)i[r].push(this.lime.direct([e.left.places[r][t],"%",e.right.places[r][t]]))}e.bs(this.lime.build("matrix")(i))})}}var pt=ut;class gt extends R{constructor(t,r){super(t,{name:"scalarMultiply",mode:r}),this.operations.b=["cl(arg{expr[1]}->expr)","cr(arg{expr[1]}->expr)","cl(bool->int)","cr(bool->int)","eb(mat,mat)","eb(mat,{comp|int|rat})","eb({comp|int|rat},mat)"],this.algorithms.set("b(mat,mat)",e=>{if(e.left.row!==e.right.row||e.left.column!==e.right.column)throw new Error("error:invalidMatrixDimensions");const i=[];for(let r=0;r<e.left.row;r++){i.push([]);for(let t=0;t<e.left.column;t++)i[r].push(this.lime.direct([e.left.places[r][t],"*",e.right.places[r][t]]))}e.bs(this.lime.build("matrix")(i))}),this.algorithms.set("b(mat,{comp|int|rat})",e=>{const i=[];for(let r=0;r<e.left.row;r++){i.push([]);for(let t=0;t<e.left.column;t++)i[r].push(this.lime.direct([e.left.places[r][t],"*",e.right]))}e.bs(this.lime.build("matrix")(i))}),this.algorithms.set("b({comp|int|rat},mat)",e=>{const i=[];for(let r=0;r<e.right.row;r++){i.push([]);for(let t=0;t<e.right.column;t++)i[r].push(this.lime.direct([e.left,"*",e.right.places[r][t]]))}e.bs(this.lime.build("matrix")(i))})}}var dt=gt;class ft extends R{constructor(t,r){super(t,{name:"scalarSubtract",mode:r}),this.operations.b=["cl(arg{expr[1]}->expr)","cr(arg{expr[1]}->expr)","cl(bool->int)","cr(bool->int)","eb(mat,mat)","eb(mat,{comp|int|rat})","eb({comp|int|rat},mat)"],this.algorithms.set("b(mat,mat)",t=>{t.bs(this.lime.direct([t.left,"-",t.right]))}),this.algorithms.set("b(mat,{comp|int|rat})",e=>{const i=[];for(let r=0;r<e.left.row;r++){i.push([]);for(let t=0;t<e.left.column;t++)i[r].push(this.lime.direct([e.left.places[r][t],"-",e.right]))}e.bs(this.lime.build("matrix")(i))}),this.algorithms.set("b({comp|int|rat},mat)",e=>{const i=[];for(let r=0;r<e.right.row;r++){i.push([]);for(let t=0;t<e.right.column;t++)i[r].push(this.lime.direct([e.left,"-",e.right.places[r][t]]))}e.bs(this.lime.build("matrix")(i))})}}var bt=ft;class vt extends R{constructor(t,r){super(t,{name:"subtract",mode:r}),this.operations.b=["tz(_-)","tr(_!)","tr(_+)","tr(_-)","cl(var->expr)","cr(var->expr)","cl(arg{expr[1]}->expr)","cr(arg{expr[1]}->expr)","cl(bool->int)","cr(bool->int)","cb(int->rat,rat)","cb(rat,int->rat)","cb({int|rat}->comp,comp)","cb(comp,{int|rat}->comp)","eb(int,int)","eb(rat,rat)","eb(comp,comp)","eb(mat,mat)"],this.algorithms.set("b(int,int)",t=>{t.bs(this.lime.build("integer")(t.left.value-t.right.value))}),this.algorithms.set("b(rat,rat)",t=>{t.bs(this.lime.build("rational")(this.lime.direct([t.left.nPlace,"*",t.right.dPlace,"-",t.right.nPlace,"*",t.left.dPlace]),this.lime.direct([t.left.dPlace,"*",t.right.dPlace])))}),this.algorithms.set("b(comp,comp)",t=>{t.bs(this.lime.build("complex")(this.lime.direct([t.left.rPlace,"-",t.right.rPlace]),this.lime.direct([t.left.iPlace,"-",t.right.iPlace])))}),this.algorithms.set("b(mat,mat)",e=>{if(e.left.row!==e.right.row||e.left.column!==e.right.column)throw new Error("error:invalidMatrixDimensions");const i=[];for(let r=0;r<e.left.row;r++){i.push([]);for(let t=0;t<e.left.column;t++)i[r].push(this.lime.direct([e.left.places[r][t],"-",e.right.places[r][t]]))}e.bs(this.lime.build("matrix")(i))})}}var xt=vt;class wt extends R{constructor(t,r){super(t,{name:"bitwiseAnd",mode:r}),this.operations.b=["tf(&&)","tr(_!)","tr(_+)","tr(_-)","cl(var->expr)","cr(var->expr)","cl(arg{expr[1]}->expr)","cr(arg{expr[1]}->expr)","cl(bool->int)","cr(bool->int)","eb(int,int)"],this.algorithms.set("b(int,int)",t=>{t.bs(this.lime.direct([t.left.value&t.right.value]))})}}var yt=wt;class _t extends R{constructor(t,r){super(t,{name:"bitwiseNot",mode:r}),this.operations.r=["tr(_!)","tr(_+)","tr(_-)","cr(var->expr)","cr(arg{expr[1]}->expr)","cr(bool->int)","er(int)"],this.algorithms.set("r(int)",t=>{t.rus(this.lime.direct([~t.right.value]))})}}var Pt=_t;class Mt extends R{constructor(t,r){super(t,{name:"bitwiseOr",mode:r}),this.operations.b=["tf(||)","tr(_!)","tr(_+)","tr(_-)","cl(var->expr)","cr(var->expr)","cl(arg{expr[1]}->expr)","cr(arg{expr[1]}->expr)","cl(bool->int)","cr(bool->int)","eb(int,int)"],this.algorithms.set("b(int,int)",t=>{t.bs(this.lime.direct([t.left.value|t.right.value]))})}}var Et=Mt;class zt extends R{constructor(t,r){super(t,{name:"shiftLeft",mode:r}),this.operations.b=["tr(_!)","tr(_+)","tr(_-)","cl(var->expr)","cr(var->expr)","cl(arg{expr[1]}->expr)","cr(arg{expr[1]}->expr)","cl(bool->int)","cr(bool->int)","eb(int,int)"],this.algorithms.set("b(int,int)",t=>{t.bs(this.lime.direct([t.left.value<<t.right.value]))})}}var It=zt;class kt extends R{constructor(t,r){super(t,{name:"shiftRight",mode:r}),this.operations.b=["tr(_!)","tr(_+)","tr(_-)","cl(var->expr)","cr(var->expr)","cl(arg{expr[1]}->expr)","cr(arg{expr[1]}->expr)","cl(bool->int)","cr(bool->int)","eb(int,int)"],this.algorithms.set("b(int,int)",t=>{t.bs(this.lime.direct([t.left.value>>t.right.value]))})}}var St=kt;class jt extends R{constructor(t,r){super(t,{name:"equal",mode:r}),this.operations.b=["tr(_!)","tr(_+)","tr(_-)","cl(var->expr)","cr(var->expr)","cl(arg{expr[1]}->expr)","cr(arg{expr[1]}->expr)","cl(bool->int)","cr(bool->int)","cb(int->rat,rat)","cb(rat,int->rat)","eb(int,int)","eb(rat,rat)"],this.algorithms.set("b(int,int)",t=>{t.bs(this.lime.build("boolean")(t.left.value===t.right.value))}),this.algorithms.set("b(rat,rat)",t=>{t.bs(this.lime.direct([t.left.nPlace,"*",t.right.dPlace,"==",t.right.nPlace,"*",t.left.dPlace]))})}}var Bt=jt;class Ot extends R{constructor(t,r){super(t,{name:"greater",mode:r}),this.operations.b=["tf(>=)","tf(>>)","tr(_!)","tr(_+)","tr(_-)","cl(var->expr)","cr(var->expr)","cl(arg{expr[1]}->expr)","cr(arg{expr[1]}->expr)","cl(bool->int)","cr(bool->int)","cb(int->rat,rat)","cb(rat,int->rat)","eb(int,int)","eb(rat,rat)"],this.algorithms.set("b(int,int)",t=>{t.bs(this.lime.build("boolean")(t.left.value>t.right.value))}),this.algorithms.set("b(rat,rat)",t=>{t.bs(this.lime.direct([t.left.nPlace,"*",t.right.dPlace,">",t.right.nPlace,"*",t.left.dPlace]))})}}var qt=Ot;class Ct extends R{constructor(t,r){super(t,{name:"greaterEqual",mode:r}),this.operations.b=["tr(_!)","tr(_+)","tr(_-)","cl(var->expr)","cr(var->expr)","cl(arg{expr[1]}->expr)","cr(arg{expr[1]}->expr)","cl(bool->int)","cr(bool->int)","cb(int->rat,rat)","cb(rat,int->rat)","eb(int,int)","eb(rat,rat)"],this.algorithms.set("b(int,int)",t=>{t.bs(this.lime.build("boolean")(t.left.value>=t.right.value))}),this.algorithms.set("b(rat,rat)",t=>{t.bs(this.lime.direct([t.left.nPlace,"*",t.right.dPlace,">=",t.right.nPlace,"*",t.left.dPlace]))})}}var At=Ct;class Dt extends R{constructor(t,r){super(t,{name:"notEqual",mode:r}),this.operations.b=["tf(!==)","tr(_!)","tr(_+)","tr(_-)","cl(var->expr)","cr(var->expr)","cl(arg{expr[1]}->expr)","cr(arg{expr[1]}->expr)","cl(bool->int)","cr(bool->int)","cb(int->rat,rat)","cb(rat,int->rat)","eb(int,int)","eb(rat,rat)"],this.algorithms.set("b(int,int)",t=>{t.bs(this.lime.build("boolean")(t.left.value!==t.right.value))}),this.algorithms.set("b(rat,rat)",t=>{t.bs(this.lime.direct([t.left.nPlace,"*",t.right.dPlace,"!=",t.right.nPlace,"*",t.left.dPlace]))})}}var Nt=Dt;class $t extends R{constructor(t,r){super(t,{name:"smaller",mode:r}),this.operations.b=["tf(<=)","tf(<<)","tr(_!)","tr(_+)","tr(_-)","cl(var->expr)","cr(var->expr)","cl(arg{expr[1]}->expr)","cr(arg{expr[1]}->expr)","cl(bool->int)","cr(bool->int)","cb(int->rat,rat)","cb(rat,int->rat)","eb(int,int)","eb(rat,rat)"],this.algorithms.set("b(int,int)",t=>{t.bs(this.lime.build("boolean")(t.left.value<t.right.value))}),this.algorithms.set("b(rat,rat)",t=>{t.bs(this.lime.direct([t.left.nPlace,"*",t.right.dPlace,"<",t.right.nPlace,"*",t.left.dPlace]))})}}var Lt=$t;class Vt extends R{constructor(t,r){super(t,{name:"smallerEqual",mode:r}),this.operations.b=["tr(_!)","tr(_+)","tr(_-)","cl(var->expr)","cr(var->expr)","cl(arg{expr[1]}->expr)","cr(arg{expr[1]}->expr)","cl(bool->int)","cr(bool->int)","cb(int->rat,rat)","cb(rat,int->rat)","eb(int,int)","eb(rat,rat)"],this.algorithms.set("b(int,int)",t=>{t.bs(this.lime.build("boolean")(t.left.value<=t.right.value))}),this.algorithms.set("b(rat,rat)",t=>{t.bs(this.lime.direct([t.left.nPlace,"*",t.right.dPlace,"<=",t.right.nPlace,"*",t.left.dPlace]))})}}var Tt=Vt;class Ft extends R{constructor(t,r){super(t,{name:"conjugate",mode:r}),this.operations.r=["cr(arg{{int|rat}[$]}->arg{comp[$]})","er(arg{comp[1]})"],this.algorithms.set("r(arg{comp[1]})",t=>{t.rus(this.lime.build("complex")(t.right.places[0].rPlace,this.lime.direct(["-",t.right.places[0].iPlace])))})}}var Rt=Ft;class Ut extends R{constructor(t,r){super(t,{name:"imaginary",mode:r}),this.operations.r=["cr(arg{{int|rat}[$]}->arg{comp[$]})","er(arg{comp[1]})"],this.algorithms.set("r(arg{comp[1]})",t=>{t.rus(this.lime.direct([t.right.places[0].iPlace]))})}}var Wt=Ut;class Zt extends R{constructor(t,r){super(t,{name:"real",mode:r}),this.operations.r=["cr(arg{{int|rat}[$]}->arg{comp[$]})","er(arg{comp[1]})"],this.algorithms.set("r(arg{comp[1]})",t=>{t.rus(this.lime.direct([t.right.places[0].rPlace]))})}}var Qt=Zt;class Gt extends R{constructor(t,r){super(t,{name:"combination",mode:r}),this.operations.r=["er(arg{int[2]})"],this.algorithms.set("r(arg{int[2]})",t=>{var[r,e]=t.right.places;if(r.value<0||e.value<0)throw new Error("warn:negativePermutation");t.rus(this.lime.direct(["npr","(",r,",",e,")","/","npr","(",e,",",e,")"]))})}}var Ht=Gt;class Jt extends R{constructor(t,r){super(t,{name:"factorial",mode:r}),this.operations.l=["tz(_!)","tf(!=)","cl(var->expr)","cl(arg{expr[1]}->expr)","cl(bool->int)","el(int)"],this.algorithms.set("l(int)",t=>{if(t.left.value<0)throw new Error("warn:negativeFactorial");0<t.left.value?t.lus(this.lime.direct([t.left,"*","(",t.left,"-",1,")","!"])):t.lus(this.lime.direct([1]))})}}var Kt=Jt;class Xt extends R{constructor(t,r){super(t,{name:"permutation",mode:r}),this.operations.r=["er(arg{int[2]})"],this.algorithms.set("r(arg{int[2]})",t=>{var[r,e]=t.right.places;if(r.value<0||e.value<0)throw new Error("warn:negativePermutation");r.value<e.value?t.rus(this.lime.direct([0])):t.rus(this.lime.direct([r,"!","/","(",r,"-",e,")","!"]))})}}var Yt=Xt;class tr extends R{constructor(t,r){super(t,{name:"logicalAnd",mode:r}),this.operations.b=["tr(_!)","tr(_+)","tr(_-)","cl(var->expr)","cr(var->expr)","cl(arg{expr[1]}->expr)","cr(arg{expr[1]}->expr)","cl({comp|int|rat}->bool)","cr({comp|int|rat}->bool)","eb(bool,bool)"],this.algorithms.set("b(bool,bool)",t=>{t.bs(this.lime.build("boolean")(t.left.value&&t.right.value))})}}var rr=tr;class er extends R{constructor(t,r){super(t,{name:"logicalNot",mode:r}),this.operations.r=["tr(_!)","tr(_+)","tr(_-)","cr(var->expr)","cr(arg{expr[1]}->expr)","cr({comp|int|rat}->bool)","er(bool)"],this.algorithms.set("r(bool)",t=>{t.rus(this.lime.build("boolean")(!t.right.value))})}}var ir=er;class sr extends R{constructor(t,r){super(t,{name:"logicalOr",mode:r}),this.operations.b=["tr(_!)","tr(_+)","tr(_-)","cl(var->expr)","cr(var->expr)","cl(arg{expr[1]}->expr)","cr(arg{expr[1]}->expr)","cl({comp|int|rat}->bool)","cr({comp|int|rat}->bool)","eb(bool,bool)"],this.algorithms.set("b(bool,bool)",t=>{t.bs(this.lime.build("boolean")(t.left.value||t.right.value))})}}var ar=sr;class lr extends R{constructor(t,r){super(t,{name:"adjoint",mode:r}),this.operations.r=["er(arg{mat[1]})"],this.algorithms.set("r(arg{mat[1]})",t=>{t.rus(this.lime.direct(["transpose","(","cof","(",t.right.places[0],")",")"]))})}}var nr=lr;class or extends R{constructor(t,r){super(t,{name:"cofactor",mode:r}),this.operations.r=["er(arg{mat[1]})"],this.algorithms.set("r(arg{mat[1]})",t=>{var e=t.right.places[0];const i=[];for(let r=0;r<e.column;r++){i.push([]);for(let t=0;t<e.row;t++)i[r].push(this.lime.direct(["det","(","minor","(",e,",",r+1,",",t+1,")",")","*",(t+r)%2?-1:1]))}t.rus(this.lime.build("matrix")(i))})}}var cr=or;class hr extends R{constructor(t,r){super(t,{name:"determinant",mode:r}),this.operations.r=["er(arg{mat[1]})"],this.algorithms.set("r(arg{mat[1]})",t=>{var r=t.right.places[0];if(r.row!==r.column)throw new Error("error:invalidMatrixDimensions");let e=this.lime.direct([0]);if(1<r.row)for(let t=0;t<r.row;t++)e=this.lime.direct([e,t%2?"-":"+",r.places[0][t],"*","det","(","minor","(",r,",",1,",",t+1,")",")"]);else e=this.lime.direct([e,"+",r.places[0][0]]);t.rus(e)})}}var mr=hr;class ur extends R{constructor(t,r){super(t,{name:"hilbertMatrix",mode:r}),this.operations.r=["er(arg{int[1]})"],this.algorithms.set("r(arg{int[1]})",t=>{var e=t.right.value[0];const i=[];for(let r=0;r<e;r++){i.push([]);for(let t=0;t<e;t++)i[r].push(this.lime.direct([1,"/",t+r+1]))}t.rus(this.lime.build("matrix")(i))})}}var pr=ur;class gr extends R{constructor(t,r){super(t,{name:"identityMatrix",mode:r}),this.operations.r=["er(arg{int[1]})"],this.algorithms.set("r(arg{int[1]})",t=>{var e=t.right.value[0];const i=[];for(let r=0;r<e;r++){i.push([]);for(let t=0;t<e;t++)i[r].push(this.lime.direct([t===r?1:0]))}t.rus(this.lime.build("matrix")(i))})}}var dr=gr;class fr extends R{constructor(t,r){super(t,{name:"index",mode:r}),this.operations.r=["er(arg{mat[1],int[1]})","er(arg{mat[1],int[2]})"],this.algorithms.set("r(arg{mat[1],int[1]})",t=>{if(t.right.value[1]<=0||t.right.value[1]>t.right.places[0].size)throw new Error("error:invalidMatrixDimensions");var r=Math.floor((t.right.value[1]-1)/t.right.places[0].column),e=(t.right.value[1]-1)%t.right.places[0].column;t.rus(t.right.places[0].places[r][e])}),this.algorithms.set("r(arg{mat[1],int[2]})",t=>{if(t.right.value[1]<=0||t.right.value[1]>t.right.places[0].row||t.right.value[2]<=0||t.right.value[2]>t.right.places[0].column)throw new Error("error:invalidMatrixDimensions");t.rus(t.right.places[0].places[t.right.value[1]-1][t.right.value[2]-1])})}}var br=fr;class vr extends R{constructor(t,r){super(t,{name:"inverse",mode:r}),this.operations.r=["er(arg{mat[1]})"],this.algorithms.set("r(arg{mat[1]})",t=>{var r=this.lime.direct(["det","(",t.right.places[0],")"]);if(0===r.value)throw new Error("warn:zeroMatrixDeterminant");t.rus(this.lime.direct(["adj","(",t.right.places[0],")","./",r]))})}}var xr=vr;class wr extends R{constructor(t,r){super(t,{name:"magicMatrix",mode:r}),this.operations.r=["er(arg{int[1]})"],this.algorithms.set("r(arg{int[1]})",t=>{var i=t.right.value[0];const a=this.lime.direct(["zeromat","(",i,")"])["places"];if(i%2==1){let t=0,r=Math.floor(i/2),e=1;for(;e<=i*i;)a[r++][t--]=this.lime.direct([e]),e++%i==0?(t+=2,r--):r===i?r-=i:t<0&&(t+=i)}else if(i%4==2){if(2===i)throw new Error("warn:magicMatrixDimensionTwo");var e=i/2,s=this.lime.direct(["magicmat","(",e,")"]).places;for(let r=0;r<e;r++)for(let t=0;t<e;t++)a[r][t]=this.lime.direct([s[r][t]]),a[r+e][t]=this.lime.direct([s[r][t],"+",3*e*e]),a[r][t+e]=this.lime.direct([s[r][t],"+",2*e*e]),a[r+e][t+e]=this.lime.direct([s[r][t],"+",e*e]);const n=[];var r=(i-2)/4;for(let t=0;t<r;t++)n.push(t+1);for(let t=i-r+1;t<i;t++)n.push(t+1);var l=(i,s)=>(t,r)=>{var e=a[s][i];a[s][i]=a[r][t],a[r][t]=e};for(let r=0;r<e;r++)for(let t=0;t<n.length;t++)l(n[t]-1,r)(n[t]-1,r+e);l(0,r)(0,r+e),l(r,r)(r,r+e)}else{const o=[];for(let r=0;r<i;r++){o.push([]);for(let t=0;t<i;t++)o[r].push(this.lime.direct([Math.floor((r+1)%4/2)])),a[r][t]=this.lime.direct([r*i+t+1])}for(let r=0;r<i;r++)for(let t=0;t<i;t++)o[r][t].value===o[t][r].value&&(a[r][t]=this.lime.direct([i*i+1,"-",a[r][t]]))}t.rus(this.lime.build("matrix")(a))})}}var yr=wr;class _r extends R{constructor(t,r){super(t,{name:"minor",mode:r}),this.operations.r=["er(arg{mat[1],int[2]})"],this.algorithms.set("r(arg{mat[1],int[2]})",e=>{if(e.right.value[1]<=0||e.right.value[1]>e.right.places[0].row||e.right.value[2]<=0||e.right.value[2]>e.right.places[0].column)throw new Error("error:invalidMatrixDimensions");const i=[];for(let r=0;r<e.right.places[0].row;r++)if(r!==e.right.value[1]-1){i.push([]);for(let t=0;t<e.right.places[0].column;t++)t!==e.right.value[2]-1&&i[i.length-1].push(e.right.places[0].places[r][t])}e.rus(this.lime.build("matrix")(i))})}}var Pr=_r;class Mr extends R{constructor(t,r){super(t,{name:"oneMatrix",mode:r}),this.operations.r=["er(arg{int[1]})","er(arg{int[2]})"],this.algorithms.set("r(arg{int[1]})",t=>{var e=t.right.value[0];const i=[];for(let r=0;r<e;r++){i.push([]);for(let t=0;t<e;t++)i[r].push(this.lime.direct([1]))}t.rus(this.lime.build("matrix")(i))}),this.algorithms.set("r(arg{int[2]})",t=>{var[e,i]=t.right.value;const s=[];for(let r=0;r<e;r++){s.push([]);for(let t=0;t<i;t++)s[r].push(this.lime.direct([1]))}t.rus(this.lime.build("matrix")(s))})}}var Er=Mr;class zr extends R{constructor(t,r){super(t,{name:"reducedRowEchelonForm",mode:r}),this.operations.r=["er(arg{mat[1]})"],this.algorithms.set("r(arg{mat[1]})",t=>{const e=t.right.places[0];let r=0,i=e.row;for(;r<i;)e.places[r].every(t=>this.lime.direct([t,"==",0]).value)?e.places.splice(--i,0,...e.places.splice(r,1)):r++;let s=r=0,a=0;for(;s<e.column&&a<i;)if(r>=i)s++,r=a;else if(this.lime.direct([e.places[r][s],"!=",0]).value){e.places.splice(a,0,...e.places.splice(r,1)),e.places[a]=e.places[a].map(t=>this.lime.direct([t,"/",e.places[a][s]]));for(let r=0;r<i;r++)if(r!==a){var l=e.places[r][s];for(let t=s;t<e.column;t++)e.places[r][t]=this.lime.direct([e.places[r][t],"-",e.places[a][t],"*",l])}a++,r=i}else r++;const n=[];for(let r=0;r<e.row;r++){n.push([]);for(let t=0;t<e.column;t++)n[r].push(e.places[r][t])}t.rus(this.lime.build("matrix")(n))})}}var Ir=zr;class kr extends R{constructor(t,r){super(t,{name:"trace",mode:r}),this.operations.r=["er(arg{mat[1]})"],this.algorithms.set("r(arg{mat[1]})",t=>{var r=t.right.places[0];if(r.row!==r.column)throw new Error("error:invalidMatrixDimensions");let e=this.lime.direct([0]);for(let t=0;t<r.row;t++)e=this.lime.direct([e,"+",r.places[t][t]]);t.rus(e)})}}var Sr=kr;class jr extends R{constructor(t,r){super(t,{name:"transpose",mode:r}),this.operations.r=["er(arg{mat[1]})"],this.algorithms.set("r(arg{mat[1]})",t=>{var e=t.right.places[0];const i=[];for(let r=0;r<e.column;r++){i.push([]);for(let t=0;t<e.row;t++)i[r].push(this.lime.direct([e.places[t][r]]))}t.rus(this.lime.build("matrix")(i))})}}var Br=jr;class Or extends R{constructor(t,r){super(t,{name:"zeroMatrix",mode:r}),this.operations.r=["er(arg{int[1]})","er(arg{int[2]})"],this.algorithms.set("r(arg{int[1]})",t=>{var e=t.right.value[0];const i=[];for(let r=0;r<e;r++){i.push([]);for(let t=0;t<e;t++)i[r].push(this.lime.direct([0]))}t.rus(this.lime.build("matrix")(i))}),this.algorithms.set("r(arg{int[2]})",t=>{var[e,i]=t.right.value;const s=[];for(let r=0;r<e;r++){s.push([]);for(let t=0;t<i;t++)s[r].push(this.lime.direct([0]))}t.rus(this.lime.build("matrix")(s))})}}var qr=Or;class Cr extends R{constructor(t,r){super(t,{name:"absolute",mode:r}),this.operations.r=["er(arg{int[1]})","er(arg{rat[1]})"],this.algorithms.set("r(arg{int[1]})",t=>{t.rus(this.lime.direct([Math.abs(t.right.value[0])]))}),this.algorithms.set("r(arg{rat[1]})",t=>{t.rus(this.lime.direct([Math.abs(t.right.value[0].n),"/",Math.abs(t.right.value[0].d)]))})}}var Ar=Cr;class Dr extends R{constructor(t,r){super(t,{name:"ceiling",mode:r}),this.operations.r=["er(arg{int[1]})","er(arg{rat[1]})"],this.algorithms.set("r(arg{int[1]})",t=>{t.rus(this.lime.direct([t.right.value[0]]))}),this.algorithms.set("r(arg{rat[1]})",t=>{t.rus(this.lime.direct([Math.ceil(t.right.value[0].n/t.right.value[0].d)]))})}}var Nr=Dr;class $r extends R{constructor(t,r){super(t,{name:"factor",mode:r}),this.operations.r=["er(arg{int[1]})"],this.algorithms.set("r(arg{int[1]})",t=>{var r=t.right.value[0];if(r<1)throw new Error("warn:invalidNumberFactor");const e=[1];for(let t=2;t<=r;t++)r%t==0&&e.push(t);t.rus(this.lime.build("matrix")([e.map(t=>this.lime.direct([t]))]))})}}var Lr=$r;class Vr extends R{constructor(t,r){super(t,{name:"fibonacci",mode:r}),this.operations.r=["er(arg{int[1]})"],this.algorithms.set("r(arg{int[1]})",t=>{var r=t.right.value[0];if(r<1)throw new Error("error:invalidSequenceIndex");this.lime.store.hasOwnProperty("fibonacci")||(this.lime.store.fibonacci=[1,1]);const e=[...this.lime.store.fibonacci];for(;e.length<r;)e.push(e[e.length-2]+e[e.length-1]);this.lime.store.fibonacci=[...e],t.rus(this.lime.direct([e[r-1]]))})}}var Tr=Vr;class Fr extends R{constructor(t,r){super(t,{name:"floor",mode:r}),this.operations.r=["er(arg{int[1]})","er(arg{rat[1]})"],this.algorithms.set("r(arg{int[1]})",t=>{t.rus(this.lime.direct([t.right.value[0]]))}),this.algorithms.set("r(arg{rat[1]})",t=>{t.rus(this.lime.direct([Math.floor(t.right.value[0].n/t.right.value[0].d)]))})}}var Rr=Fr;class Ur extends R{constructor(t,r){super(t,{name:"greatestCommonDivisor",mode:r}),this.operations.r=["er(arg{int[2]})"],this.algorithms.set("r(arg{int[2]})",t=>{let r=t.right.value[0],e=t.right.value[1];for(;0!==e;){var i=e;e=r%e,r=i}t.rus(this.lime.direct([r]))})}}var Wr=Ur;class Zr extends R{constructor(t,r){super(t,{name:"leastCommonMultiple",mode:r}),this.operations.r=["er(arg{int[2]})"],this.algorithms.set("r(arg{int[2]})",t=>{var r=t.right.value[0],e=t.right.value[1];t.rus(this.lime.direct([r,"*",e,"/","gcd","(",r,",",e,")"]))})}}var Qr=Zr;class Gr extends R{constructor(t,r){super(t,{name:"prime",mode:r}),this.operations.r=["er(arg{int[1]})"],this.algorithms.set("r(arg{int[1]})",t=>{var r=t.right.value[0];if(r<1)throw new Error("error:invalidSequenceIndex");this.lime.store.hasOwnProperty("prime")||(this.lime.store.prime=[2]);const e=[...this.lime.store.prime];let i=e[e.length-1]+1;for(;e.length<r;)e.every(t=>i%t!=0)&&e.push(i),i++;this.lime.store.prime=[...e],t.rus(this.lime.direct([e[r-1]]))})}}var Hr=Gr;class Jr extends R{constructor(t,r){super(t,{name:"reciprocal",mode:r}),this.operations.r=["er(arg{expr[1]})"],this.algorithms.set("r(arg{expr[1]})",t=>{t.rus(this.lime.direct([1,"/",t.right.places[0]]))})}}var Kr=Jr;class Xr extends R{constructor(t,r){super(t,{name:"round",mode:r}),this.operations.r=["er(arg{int[1]})","er(arg{rat[1]})"],this.algorithms.set("r(arg{int[1]})",t=>{t.rus(this.lime.direct([t.right.value[0]]))}),this.algorithms.set("r(arg{rat[1]})",t=>{t.rus(this.lime.direct([Math.round(t.right.value[0].n/t.right.value[0].d)]))})}}var Yr=Xr;class te extends R{constructor(t,r){super(t,{name:"sign",mode:r}),this.operations.r=["er(arg{int[1]})","er(arg{rat[1]})"],this.algorithms.set("r(arg{int[1]})",t=>{t.rus(this.lime.direct([Math.sign(t.right.value[0])]))}),this.algorithms.set("r(arg{rat[1]})",t=>{t.rus(this.lime.direct([Math.sign(t.right.value[0].n/t.right.value[0].d)]))})}}var re=te;class ee extends R{constructor(t,r){super(t,{name:"truncation",mode:r}),this.operations.r=["er(arg{int[1]})","er(arg{rat[1]})"],this.algorithms.set("r(arg{int[1]})",t=>{t.rus(this.lime.direct([t.right.value[0]]))}),this.algorithms.set("r(arg{rat[1]})",t=>{t.rus(this.lime.direct([Math.trunc(t.right.value[0].n/t.right.value[0].d)]))})}}var ie=ee;class se extends R{constructor(t,r){super(t,{name:"intersection",mode:r}),this.operations.r=["er(arg{set[2]})"],this.algorithms.set("r(arg{set[2]})",t=>{const e=t.right.places[0],i=t.right.places[1],s=[];for(let r=0;r<e.length;r++)i.places.some(t=>this.lime.direct([e.places[r],"==",t]).value)&&s.push(e.places[r]);t.rus(this.lime.build("set")(...s))})}}var ae=se;class le extends R{constructor(t,r){super(t,{name:"union",mode:r}),this.operations.r=["er(arg{set[2]})"],this.algorithms.set("r(arg{set[2]})",t=>{const e=t.right.places.map(t=>t.places).flat(),i=this.lime.direct(["intersection","(",t.right.places[0],",",t.right.places[1],")"]).places;for(let r=0;r<e.length;r++)i.some(t=>this.lime.direct([e[r],"==",t]).value)&&e.splice(r,1);t.rus(this.lime.build("set")(...e,...i))})}}var ne=le;class oe extends R{constructor(t,r){super(t,{name:"maximum",mode:r}),this.operations.r=["er(arg{expr[@]})"],this.algorithms.set("r(arg{expr[@]})",r=>{let e=0;for(let t=1;t<r.right.length;t++)e=this.lime.direct([r.right.places[t],">",r.right.places[e]]).value?t:e;r.rus(this.lime.direct([r.right.places[e]]))})}}var ce=oe;class he extends R{constructor(t,r){super(t,{name:"mean",mode:r}),this.operations.r=["er(arg{expr[@]})"],this.algorithms.set("r(arg{expr[@]})",t=>{t.rus(this.lime.direct(["sum",t.right,"/",t.right.length]))})}}var me=he;class ue extends R{constructor(t,r){super(t,{name:"minimum",mode:r}),this.operations.r=["er(arg{expr[@]})"],this.algorithms.set("r(arg{expr[@]})",r=>{let e=0;for(let t=1;t<r.right.length;t++)e=this.lime.direct([r.right.places[t],"<",r.right.places[e]]).value?t:e;r.rus(this.lime.direct([r.right.places[e]]))})}}var pe=ue;class ge extends R{constructor(t,r){super(t,{name:"product",mode:r}),this.operations.r=["er(arg{expr[@]})"],this.algorithms.set("r(arg{expr[@]})",r=>{let e=r.right.places[0];for(let t=1;t<r.right.length;t++)e=this.lime.direct([e,"*",r.right.places[t]]);r.rus(this.lime.direct([e]))})}}var de=ge;class fe extends R{constructor(t,r){super(t,{name:"random",mode:r}),this.operations.r=["er(arg{})","er(arg{int[1]})","er(arg{int[2]})"],this.algorithms.set("r(arg{})",t=>{t.rus(this.lime.direct([Math.floor(1e15*Math.random()),"/",1e15]))}),this.algorithms.set("r(arg{int[1]})",t=>{t.rus(this.lime.direct(["rand","(",0,",",t.right.places[0],")"]))}),this.algorithms.set("r(arg{int[2]})",t=>{var[r,e]=t.right.places;if(this.lime.direct([r.value,">",e.value]).value)throw new Error("error:invalidArgumentLogic");t.rus(this.lime.direct([Math.floor(Math.random()*(e.value-r.value+1)+r.value)]))})}}var be=fe;class ve extends R{constructor(t,r){super(t,{name:"range",mode:r}),this.operations.r=["er(arg{expr[@]})"],this.algorithms.set("r(arg{expr[@]})",t=>{t.rus(this.lime.direct(["max",t.right,"-","min",t.right]))})}}var xe=ve;class we extends R{constructor(t,r){super(t,{name:"sum",mode:r}),this.operations.r=["er(arg{expr[@]})"],this.algorithms.set("r(arg{expr[@]})",r=>{let e=r.right.places[0];for(let t=1;t<r.right.length;t++)e=this.lime.direct([e,"+",r.right.places[t]]);r.rus(this.lime.direct([e]))})}}var ye=we;class _e extends R{constructor(t,r){super(t,{name:"concatenate",mode:r}),this.operations.r=["er(arg{str[@]})"],this.algorithms.set("r(arg{str[@]})",t=>{t.rus(this.lime.build("string")(t.right.value[0].concat(...t.right.value.slice(1))))})}}var Pe=_e;class Me extends R{constructor(t,r){super(t,{name:"length",mode:r}),this.operations.r=["er(arg{str[1]})"],this.algorithms.set("r(arg{str[1]})",t=>{t.rus(this.lime.direct([t.right.value[0].length]))})}}var Ee=Me;class ze extends R{constructor(t,r){super(t,{name:"assign",mode:r}),this.operations.b=["tf(==)","tr(_+)","tr(_-)","cr(var->expr)","cr(arg{expr[1]}->expr)","eb(var,expr)"],this.algorithms.set("b(var,expr)",t=>{this.lime.variables.set(t.left.key,t.right),t.bs(t.left)})}}var Ie=ze;class ke extends R{constructor(t,r){super(t,{name:"columnSplit",mode:r})}}var Se=ke;class je extends R{constructor(t,r){super(t,{name:"commonBracket",mode:r}),this.operations.n=["en()"],this.algorithms.set("n()",t=>{var r=t["data"];const e=[[]],i=[this];let s=t.pos,a=0;for(;s+1<r.length&&0<i.length;)if(this.lime.identify("commonBracket","matrixBracket","setBracket")(r[s+1])){if("n"===r[s+1].mode)i.push(r[s+1]);else{if(r[s+1].name!==i[i.length-1].name)throw new Error("error:unmatchedBrackets");if(i.pop(),0===i.length)break}e[a].push(r[++s])}else if(this.lime.identify("columnSplit")(r[s+1])&&1===i.length)e.push([]),a++,s++;else{if(this.lime.identify("rowSplit")(r[s+1])&&1===i.length)throw new Error("error:functionAgreement");e[a].push(r[++s])}if(0<i.length)throw new Error("error:unmatchedBrackets");const l=[];let n=2+a;for(let t=0;t<=a;t++)n+=e[t].length,l.push(0<e[t].length?this.lime.direct(e[t]):null);t.ns(n,this.lime.build("argument")(...l))})}}var Be=je;class Oe extends R{constructor(t,r){super(t,{name:"matrixBracket",mode:r}),this.operations.n=["en()"],this.algorithms.set("n()",t=>{var r=t["data"];const e=[[[]]],i=[this];let s=t.pos,a=0,l=0;for(;s+1<r.length&&0<i.length;)if(this.lime.identify("commonBracket","matrixBracket","setBracket")(r[s+1])){if("n"===r[s+1].mode)i.push(r[s+1]);else{if(r[s+1].name!==i[i.length-1].name)throw new Error("error:unmatchedBrackets");if(i.pop(),0===i.length)break}e[a][l].push(r[++s])}else if(this.lime.identify("columnSplit")(r[s+1])&&1===i.length)e[a].push([]),l++,s++;else if(this.lime.identify("rowSplit")(r[s+1])&&1===i.length){if(0<a&&e[a].length!==e[0].length)throw new Error("error:invalidArgumentLogic");e.push([[]]),a++,l=0,s++}else e[a][l].push(r[++s]);if(0<i.length)throw new Error("error:unmatchedBrackets");const n=[];let o=++a*++l+1;for(let r=0;r<a;r++){n.push([]);for(let t=0;t<l;t++)o+=e[r][t].length,0<e[r][t].length&&n[r].push(this.lime.direct(e[r][t]))}t.ns(o,this.lime.build("matrix")(n))})}}var qe=Oe;class Ce extends R{constructor(t,r){super(t,{name:"property",mode:r}),this.operations.b=["tf(_.)","tf(.+)","tf(./)","tf(.^)","tf(.%)","tf(.*)","tf(.-)","eb(expr,str)"],this.algorithms.set("b(expr,str)",t=>{t.bs(t.left[t.right.value])})}}var Ae=Ce;class De extends R{constructor(t,r){super(t,{name:"omitted",mode:r}),this.operations.b=["eb(mat,arg{int[1]})","eb(expr,expr)"],this.algorithms.set("b(mat,arg{int[1]})",t=>{t.bs(t.lime.direct(["index","(",t.left,",",t.right,")"]))}),this.algorithms.set("b(expr,expr)",t=>{t.fs(t.lime.refer("*"))})}}var Ne=De;class $e extends R{constructor(t,r){super(t,{name:"rowSplit",mode:r})}}var Le=$e;class Ve extends R{constructor(t,r){super(t,{name:"setBracket",mode:r}),this.operations.n=["en()"],this.algorithms.set("n()",t=>{var r=t["data"];const e=[[]],i=[this];let s=t.pos,a=0;for(;s+1<r.length&&0<i.length;)if(this.lime.identify("commonBracket","matrixBracket","setBracket")(r[s+1])){if("n"===r[s+1].mode)i.push(r[s+1]);else{if(r[s+1].name!==i[i.length-1].name)throw new Error("error:unmatchedBrackets");if(i.pop(),0===i.length)break}e[a].push(r[++s])}else if(this.lime.identify("columnSplit")(r[s+1])&&1===i.length)e.push([]),a++,s++;else{if(this.lime.identify("rowSplit")(r[s+1])&&1===i.length)throw new Error("error:functionAgreement");e[a].push(r[++s])}if(0<i.length)throw new Error("error:unmatchedBrackets");const l=[];let n=2+a;for(let t=0;t<=a;t++)n+=e[t].length,0<e[t].length&&l.push(this.lime.direct(e[t]));t.ns(n,this.lime.build("set")(...l))})}}var Te=Ve;class Fe extends R{constructor(t,r){super(t,{name:"memory",mode:r}),this.operations.r=["er(arg{int[1]})"],this.algorithms.set("r(arg{int[1]})",t=>{var r=this.lime.memory,e=t.right.value[0]-1;if(e<0||e>=r.length)throw new Error("error:invalidMemoryIndex");t.rus(r[e].result[0])})}}var Re=Fe;class Ue extends R{constructor(t,r){super(t,{name:"type",mode:r}),this.operations.r=["er(arg{expr[1]})"],this.algorithms.set("r(arg{expr[1]})",t=>{t.rus(this.lime.build("string")(t.right.places[0].name))})}}var We=Ue;var Ze=class{constructor(t,r){this.lime=t,this.input=r,this.solution=[]}get steps(){return this.solution.length}get runtime(){return this.solution[this.steps-1].timestamp-this.solution[0].timestamp}get result(){return this.solution[this.steps-1].data}record(t){this.lime.config.promptShowSteps&&console.log(t.data),this.solution.push(t)}};const Qe=t["Types"];var Ge=class{constructor(t,r,e){this.lime=t,this.data=Qe.isArray(r)?r:[],this.pos=Qe.isNumber(e)&&0<=e&&e<this.data.length?e:-1,this.timestamp=Date.now()}get left(){return this.data[this.pos-1]}get func(){return this.data[this.pos]}get right(){return this.data[this.pos+1]}ci(...r){return(...t)=>this.lime.identify(...r)(...t)}lpi(...t){return this.lime.identify(...t)(this.left)}fi(...t){return this.lime.identify(...t)(this.func)}rpi(...t){return this.lime.identify(...t)(this.right)}bpi(...t){return this.lime.identify(...t)(this.left,this.right)}lps(...t){this.data.splice(this.pos-1,1,...t)}fs(...t){this.data.splice(this.pos,1,...t)}rps(...t){this.data.splice(this.pos+1,1,...t)}lus(...t){this.data.splice(this.pos-1,2,...t)}rus(...t){this.data.splice(this.pos,2,...t)}bs(...t){this.data.splice(this.pos-1,3,...t)}ns(t,...r){this.data.splice(this.pos,t,...r)}};const He=t["Types"];var Je=class{constructor(t,r,e){this.lime=t,this.type=["integer","whitespace","symbol","variable"].includes(r)?r:"symbol",this.value=He.isString(e)?e:""}};const Ke={strc:t=>t.map(([t,r])=>{const e=""+t.charAt(0).toUpperCase()+t.slice(1);return Object.defineProperty(r,"name",{value:e.startsWith("Lime")?e:"Lime"+e}),[t,r]}),cmd:t=>t.map(([t,r])=>{const e=""+t.charAt(0).toUpperCase()+t.slice(1);return Object.defineProperty(r,"name",{value:e.startsWith("LimeCommand")?e:"LimeCommand"+e}),[t,r]}),expr:t=>t.map(([t,r])=>{const e=""+t.charAt(0).toUpperCase()+t.slice(1);return Object.defineProperty(r,"name",{value:e.startsWith("LimeExpression")?e:"LimeExpression"+e}),[t,r]}),func:t=>t.map(([t,r])=>{const e=""+t.charAt(0).toUpperCase()+t.slice(1);return Object.defineProperty(r,"name",{value:e.startsWith("LimeFunction")?e:"LimeFunction"+e}),[t,r]})};Je=new Map([].concat(Ke.cmd([["about",s],["clear",a],["config",l],["help",d],["list",b]]),Ke.expr([["argument",_],["boolean",M],["complex",z],["integer",S],["matrix",B],["rational",q],["set",A],["string",N],["variable",L]]),Ke.func([["add",W],["decimal",Q],["divide",H],["exponent",K],["modulo",Y],["multiply",rt],["negative",it],["positive",at],["scalarAdd",nt],["scalarDivide",ct],["scalarExponent",mt],["scalarModulo",pt],["scalarMultiply",dt],["scalarSubtract",bt],["subtract",xt]]),Ke.func([["bitwiseAnd",yt],["bitwiseNot",Pt],["bitwiseOr",Et],["shiftLeft",It],["shiftRight",St]]),Ke.func([["equal",Bt],["greater",qt],["greaterEqual",At],["notEqual",Nt],["smaller",Lt],["smallerEqual",Tt]]),Ke.func([["conjugate",Rt],["imaginary",Wt],["real",Qt]]),Ke.func([["combination",Ht],["factorial",Kt],["permutation",Yt]]),Ke.func([["logicalAnd",rr],["logicalNot",ir],["logicalOr",ar]]),Ke.func([["adjoint",nr],["cofactor",cr],["determinant",mr],["hilbertMatrix",pr],["identityMatrix",dr],["index",br],["inverse",xr],["magicMatrix",yr],["minor",Pr],["oneMatrix",Er],["reducedRowEchelonForm",Ir],["trace",Sr],["transpose",Br],["zeroMatrix",qr]]),Ke.func([["absolute",Ar],["ceiling",Nr],["factor",Lr],["fibonacci",Tr],["floor",Rr],["greatestCommonDivisor",Wr],["leastCommonMultiple",Qr],["prime",Hr],["reciprocal",Kr],["round",Yr],["sign",re],["truncation",ie]]),Ke.func([["intersection",ae],["union",ne]]),Ke.func([["maximum",ce],["mean",me],["minimum",pe],["product",de],["random",be],["range",xe],["sum",ye]]),Ke.func([["concatenate",Pe],["length",Ee]]),Ke.func([["assign",Ie],["columnSplit",Se],["commonBracket",Be],["matrixBracket",qe],["property",Ae],["omitted",Ne],["rowSplit",Le],["setBracket",Te]]),Ke.func([["memory",Re],["type",We]]),Ke.strc([["command",e],["equation",Ze],["expression",x],["function",R],["step",Ge],["token",Je]])));const Xe=t["Types"],Ye=Je,ti={decimalPlaces:-1,developmentMode:!1,promptShowRuntime:!1,promptShowSteps:!1,strictBoolean:!0,tabSize:2,testMode:!1},ri={github:"Please create a GitHub issue about how you received this message, thank you. ","error:emptyArgumentInFinalize":"Empty argument in finalize function.","error:functionAgreement":"Function does not agree with parameter types.","error:inputEmptyInDirect":"Direct input is empty.","error:inputEmptyInPrompt":"Prompt input is empty.","error:inputNotArrayInDirect":"Direct input is not an array.","error:inputNotStringInPrompt":"Prompt input is not a string.","error:invalidArgumentLength":"Invalid argument length.","error:invalidArgumentLogic":"Invalid argument logic.","error:invalidConfigProperty":"Invalid configuration property in config command","error:invalidListProperty":"Invalid list property in list command","error:invalidMatrixDimensions":"Invalid matrix dimensions.","error:invalidMemoryIndex":"Invalid index for accessing memory.","error:invalidParametersInCommand":"Invalid parameters in command.","error:invalidSequenceIndex":"Invalid sequence index argument.","error:invalidSymbol":"Invalid symbol in prompt input.","error:undefinedVariable":"Variable is undefined but used.","error:unmatchedBrackets":"Some brackets are unmatched.","issue:invalidExpressionInConstruct":"Invalid expression in constructor.","issue:invalidFunctionOrder":"Invalid function order.","issue:invalidMessage":"Invalid message detected.","issue:invalidModuleInBuild":"Invalid module in build function.","issue:invalidModuleInIdentify":"Invalid module in identify function.","issue:invalidResultLengthInProcess":"Invalid result length in process function.","issue:invalidTokenInParse":"Invalid token in parse function.","warn:invalidNumberFactor":"Integer input smaller than 1 cannot be factored.","warn:negativeFactorial":"Factorial function has negative integer input. Currenly gamma function has not been implemented.","warn:negativePermutation":"Permutation parameters is negative.","warn:strictBoolean":"Strict boolean configuration is set to true. Boolean to expression conversion is not allowed.","warn:magicMatrixDimensionTwo":"There is no magic matrix with dimension 2.","warn:zeroExponentOfZero":"Zero raised to exponent of zero is undefined.","warn:zeroMatrixDeterminant":"Determinant of matrix is zero."},ei={about:["about"],clear:["clear"],config:["config"],help:["help"],list:["list"],false:["boolean",!1],i:["complex",["integer",0],["integer",1]],true:["boolean",!0],"()":["argument",null],abs:["absolute","r"],adj:["adjoint","r"],ceil:["ceiling","r"],cof:["cofactor","r"],concat:["concatenate","r"],conj:["conjugate","r"],det:["determinant","r"],factor:["factor","r"],fibonacci:["fibonacci","r"],floor:["floor","r"],gcd:["greatestCommonDivisor","r"],hilbmat:["hilbertMatrix","r"],idmat:["identityMatrix","r"],im:["imaginary","r"],index:["index","r"],intersection:["intersection","r"],inv:["inverse","r"],lcm:["leastCommonMultiple","r"],len:["length","r"],magicmat:["magicMatrix","r"],max:["maximum","r"],mean:["mean","r"],mem:["memory","r"],min:["minimum","r"],minor:["minor","r"],ncr:["combination","r"],npr:["permutation","r"],onemat:["oneMatrix","r"],prime:["prime","r"],prod:["product","r"],rand:["random","r"],range:["range","r"],re:["real","r"],reciprocal:["reciprocal","r"],round:["round","r"],rref:["reducedRowEchelonForm","r"],sgn:["sign","r"],sum:["sum","r"],tr:["trace","r"],transpose:["transpose","r"],trunc:["truncation","r"],type:["type","r"],union:["union","r"],zeromat:["zeroMatrix","r"],"+":["add","b"],"=":["assign","b"],"&":["bitwiseAnd","b"],"~":["bitwiseNot","r"],"|":["bitwiseOr","b"],",":["columnSplit","x"],"(":["commonBracket","n"],")":["commonBracket","x"],"_.":["decimal","b"],"/":["divide","b"],"==":["equal","b"],"^":["exponent","b"],"!":["factorial","l"],">":["greater","b"],">=":["greaterEqual","b"],"&&":["logicalAnd","b"],"_!":["logicalNot","r"],"||":["logicalOr","b"],"[":["matrixBracket","n"],"]":["matrixBracket","x"],"%":["modulo","b"],"*":["multiply","b"],"_-":["negative","r"],"!=":["notEqual","b"],"_+":["positive","r"],".":["property","b"],";":["rowSplit","x"],".+":["scalarAdd","b"],"./":["scalarDivide","b"],".^":["scalarExponent","b"],".%":["scalarModulo","b"],".*":["scalarMultiply","b"],".-":["scalarSubtract","b"],"{":["setBracket","n"],"}":["setBracket","x"],"<<":["shiftLeft","b"],">>":["shiftRight","b"],"<":["smaller","b"],"<=":["smallerEqual","b"],"-":["subtract","b"]};class ii{constructor(t){this.config={...ti,...t},this.module=Ye,this.variables=new Map,this.memory=[],this.store={}}get answer(){return this.variables.get("ans").print()}prompt(t){try{return this.run(t)}catch(t){return this.message(t)}}evaluate(t){try{return this.run(t)}catch(t){return this.config.testMode||console.log(this.message(t)),""}}run(t){if(!Xe.isString(t))throw new Error("error:inputNotStringInPrompt");if(0===t.length)throw new Error("error:inputEmptyInPrompt");this.variables.has("ans")||this.variables.set("ans",this.direct([0]));const r=this.build("equation")(t);return this.lex(r),this.identify("command")(r.result[0])?r.result[0].execute(t):(this.memory.push(r),this.config.promptShowRuntime&&console.log(`Equation runtime: ${r.runtime/1e3}s`),this.variables.set("ans",r.result[0]),this.answer)}direct(t){try{if(!Xe.isArray(t))throw new Error("error:inputNotArrayInDirect");if(0===t.length)throw new Error("error:inputEmptyInDirect");const r=this.build("equation")(t);return r.record(this.build("step")(r.input.map(t=>!Xe.isString(t)&&!Xe.isNumber(t)||Xe.isUndefined(this.refer(t))?t:this.refer(t)))),this.process(r),r.result[0]}catch(t){return this.config.testMode?this.message(t):void console.log(this.message(t))}}message(t){var r=new Error("issue:invalidMessage");if(!ri.hasOwnProperty(t.message)||!t.message.includes(":"))return console.log(t),this.message(r);var e=t.message.split(":");let i;switch(e[0]){case"error":i="!";break;case"warn":i="?";break;case"issue":i="i";break;default:return this.message(r)}return this.config.developmentMode&&"i"===i&&console.log(t),`[${i}] ${e[1]}
${ri[t.message]} `+("i"===i?`
`+ri.github:"")}lex(t){const e=t.input,i=[];for(let r=0;r<e.length;r++){const s=e[r];let t=s;if(s.match(/\s/))i.push(this.build("token")("whitespace"));else if(s.match(/\d/)){for(;r+1<e.length&&e[r+1].match(/\d/);)t+=e[++r];i.push(this.build("token")("integer",t))}else if(s.match(/\w/)){for(;r+1<e.length&&e[r+1].match(/\w/);)t+=e[++r];i.push(this.build("token")("variable",t))}else i.push(this.build("token")("symbol",t))}t.record(i),this.parse(t)}parse(t){var r=t.solution.shift();const e=[];let i=!1,s="";for(let t=0;t<r.length;t++){switch(r[t].type){case"whitespace":break;case"integer":e.push(this.build("integer")(r[t].value));break;case"symbol":case"variable":if('"'===r[t].value)i=!0,s="";else if(ei.hasOwnProperty(r[t].value))e.push(this.refer(r[t].value));else{if("variable"!==r[t].type)throw new Error("error:invalidSymbol");e.push(this.build("variable")(r[t].value))}break;default:throw new Error("issue:invalidTokenInParse")}for(;t+1<r.length&&i;)'"'===r[t+1].value?(e.push(this.build("string")(s)),i=!1,t++):s+=""+("whitespace"===r[++t].type?" ":r[t].value)}if(i)throw new Error("error:unmatchedBrackets");t.record(this.build("step")(e)),this.identify("command")(t.result[0])||this.process(t)}process(e){for(;;){for(let t=0;t<e.result.length;t++)0<t&&this.identify("expression")(e.result[t-1],e.result[t])&&e.result.splice(t,0,this.build("omitted")("b"));let r=-1;for(let t=0;t<e.result.length;t++)this.identify("function")(e.result[t])&&(r=r<0||e.result[t].order>e.result[r].order?t:r);if(r<0)break;var t=this.build("step")(e.result,r);e.record(e.result[r].evaluate(t))}if(1!==e.result.length||this.identify("argument")(e.result[0])&&1!==e.result[0].length)throw new Error("issue:invalidResultLengthInProcess");e.record(this.build("step")([e.result[0].finalize()]))}identify(...e){if(e.every(t=>this.module.has(t)))return(...t)=>t.every(r=>e.some(t=>Xe.isClass(this.module.get(t),r)));throw new Error("issue:invalidModuleInIdentify")}build(r){if(this.module.has(r))return(...t)=>new(this.module.get(r))(this,...t);throw new Error("issue:invalidModuleInBuild")}refer(t){return Xe.isNumber(t)?this.build("integer")(t):ei.hasOwnProperty(t)?this.build(ei[t][0])(...ei[t].slice(1).map(t=>Xe.isArray(t)?this.build(t[0])(...t.slice(1)):t)):void 0}}return t=>new ii(t)});
